<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>prototype/prototype</title>
    <link href="/2021/03/17/prototype/prototype/"/>
    <url>/2021/03/17/prototype/prototype/</url>
    
    <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><hr><p><strong>constructor</strong> 返回实例对象构造函数的引用，此值是对函数本身的引用</p><pre>function Person (name) {    this.name = name;}var p = new Person(name);p.constructor === Person</pre><p>构造函数本身就是函数，不过为了规范都会首字母大写， 主要<code>区别</code>在于使用 <em>new</em> 生成的实例函数就是构造函数，直接调用的就是普通函数 </p><h3 id="constructor-是只读的吗？"><a href="#constructor-是只读的吗？" class="headerlink" title="constructor 是只读的吗？"></a>constructor 是只读的吗？</h3><p>对引用类型来是可以修改的，对基本数据类型是 只读的</p><pre>function Parent() {    this.name = 'xiaoming';    this.age = '18';}Parent.prototype = {    method: funtion () {}}function Children() {}Children.prototype = new Parent();Children.prototype.foo = 'Hello world'//此时constructor 指向 ObjectChildren.prototype.constructor === Object //true//修正constructorChildren.prototype.constructor = Children</pre><h3 id="new-到底是如果实现的呢"><a href="#new-到底是如果实现的呢" class="headerlink" title="new 到底是如果实现的呢"></a>new 到底是如果实现的呢</h3><pre>function create () {    // 创建一个空对象    var obj = new Object(),    //2. 获得构造函数，同时删除arguments 里的第一个参数    Con = [].shift.call(arguments);    //3. 链接到原型，obj可以访问到构造函数的属性    Object.setPrototypeOf(obj, Con.prototype)    //4.绑定this实现继承，让其可以访问构造函数的属性    var result = Con.apply(obj, arguments)    //优先返回构造函数的对象    return result instanceof Object ? result : obj}</pre><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><p>每个构造函数对象拥有一个<strong>原型对象</strong>，对象以原型为模板，从原型继承方法和属性，这些属性和方法定义在构造器函数的 <strong>prototype</strong> 属性上，而非本身</p><h2 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a>_<em>proto_</em></h2><p>构造函数的 prototype 属性有个 _<em>proto__属性，这是一个访问器属性（即getter 函数和 setter函数），通过他可以访问到对象内部的 [[Prototype]](一个对象或null)<br>##<br><em>_prototype</em></em> 属性在es6后才被标准化，获取或者设置可以用</p><pre>    Object.setPrototypeOf()    Object.getPrototypeOf()</pre><p>##原型链<br>每个对象拥有原型对象，通过<strong>proto</strong>指针指向该对象的原型，并从中集成方法和属性， 同时原型对象也可能拥有原型，这样一层一层，最终会指向null；这种关系被称作原型链</p><h2 id="实现-instanceOf"><a href="#实现-instanceOf" class="headerlink" title="实现 instanceOf"></a>实现 instanceOf</h2><pre>function _instanceOf (instance, object){    // 获取对象的原型    const prototype = object.prototype;    //获取要检查对象的原型    let proto = instance.__proto__;    //遍历要检查的原型链，until the end of instance    while (__proto__ !== null) {        if (__proto__ === prototype) {            return true;        }        proto =  proto.__proto__;    }    return false;}</pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Gallery</title>
    <link href="/2021/03/17/hello-world/"/>
    <url>/2021/03/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>摘要…</p><a id="more"></a><p>正文…</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><p><a href="source/data/promise/1.md">阅读更多…</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/BinarySearchTree</title>
    <link href="/2021/03/17/algorithm/BinarySearchTree/"/>
    <url>/2021/03/17/algorithm/BinarySearchTree/</url>
    
    <content type="html"><![CDATA[/** * 二叉搜索树 * 每个节点都有数据，另外含有两个指针，指向其他节点 * 特点：节点顺序基于节点值的大小，所有左节点的值都小于右节点的值 */var node = {    value: 124,    left: null,    right: null};function BinarySearchTree() {    this._root = null}BinarySearchTree.prototype = {    constructor: BinarySearchTree,    add: function (value) {        var node = {            value: value,            left: null,            right: null        },        current;        if (this._root === null) {            this._root = node;        } else {            current = this._root            while (true) {                if(value < current.value) {                    if (current.left === null) {                        current.left = node                        break;                    } else {                        current = current.left                    }                } else if (value >  current.right) {                    if (current.right === null) {                        current.right = node                        break                    } else {                        current = current.right                    }                } else {                    break                }            }        }    },    contains: function (value) {        var found = false,            current = this._root;        while (!found && current) {            if (value < current.value) {                current = current.right            } else if (value > current.value) {                current = current.left            } else {                found = true            }        }        return found        },    remove: function (value) {        var found = false,            parent = null,            current = this._root,            childCount,            replacement,            replacementParent;       // 定位要删除的节点 父节点要被记录              while(!found && current) {            if(value < current.value) {                parent = current                current = current.left            }else if (value > current.value) {                parent = current                current = current.right            } else {                found = true            }        }        if (found) {          // 计算节点数量            childCount = (current.left === null ? 0 : 1) + (current.right === null ? 0 : 1)            if(current === this._root) {                switch(childCount){                    case 0:                        this._root = null;                        break;                    case 1:                        this._root = current.right === null ? current.left : current.right                        break;                    case 2:                        //新的根节点是源根节点的做子节点                        //左子树的最右节点 直接前驱                        replacement = this._root.left                        while (replacement.right !== null) {                            replacementParent = replacement                            replacement = replacement.right                        }                        if(replacementParent !== null) {                            replacementParent.right = replacement.left                            replacement.right = this._root.right                            replacement.left = this._root.left                        }                        this._root = replacement                }            } else {                switch(childCount){                    case 0:                        if(current.value > parent.value) {                            parent.left = null;                        } else {                            parent.right = null                        }                        break;                    case 1:                        if(current.value > parent.value) {                        parent.left = current.left ? current.left.value : current.right.value                    } else {                        parent.right = current.left ? current.left.value : current.right.value                    }                    case 2:                      //TODO                        replacement = current.left                        replacementParent = current                        while (replacement.right !== null) {                            replacementParent = replacement                            replacement = replacement.right                        }                        replacementParent = replacement.left                         replacementParent.right = current.right                        replacementParent.left = current.left                        if (parent.value > replacement.value) {                            parent.left = replacement                        } else {                            parent.right = replacement                        }                }            }        }    },    size: function () {        var length = 0;        this.traverse(function(node){            length++;        })        return length    },    traverse: function (process) {        // 辅助函数遍历节点        function inOrder(node) {            if(node.left !== null) {                inOrder(node.left)            }            // call 使用指定的this 和单独给出的一个或多个参数调用一个函数，再次此处调用process            process.call(this, node);            if (node.right !== null) {                inOrder(node.right)            }        }        inOrder(this._root)    },    toArray: function () {        var result = [];        this.traverse(function(node){            result.push(node.value)        })        return result    },    toString: function () {        return this.toArray().toString();    },}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/BubbleSort</title>
    <link href="/2021/03/17/algorithm/BubbleSort/"/>
    <url>/2021/03/17/algorithm/BubbleSort/</url>
    
    <content type="html"><![CDATA[/** * 冒泡排序 * 比较前两个元素 -> 如果第一个元素应该排在第二个后面，则两者交换 -> 比较第二个与第三个元素  * 如果第二个元素应该在第三个后面，两者交换 -> 重复以上过程知道末尾 * 时间复杂度 平均复杂度O(n*n), 最好情况O(n), 最差情况(n*n) * 空间复杂度 O(1) * 稳定性 稳定 */function swap(items, firstIndex, secondIndex) {    var temp = items[firstIndex];    items[firstIndex] = items[secondIndex]    items[secondIndex] = temp}/** * 外层循环负责遍历，内层循环负责数组的元素比较 *  */function bubbleSort(items) {    var len = items.length,            i,            j,            stop;    for (i = 0; i < len; i++) {        var done = true        for(j = 0, stop = len-i-1; j < stop; j++) {            if(items[j] < item[j+1]) {                swap(items, j, j+1)                done = false            }        }        if (done) {            break;        }    }    return items}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/base64</title>
    <link href="/2021/03/17/algorithm/base64/"/>
    <url>/2021/03/17/algorithm/base64/</url>
    
    <content type="html"><![CDATA[function generateArray(length, arr = []) {  let randomNum = Math.floor((Math.random()*30)+2);  if(arr.indexOf(randomNum) === -1) {    arr.push(randomNum);  }  return arr.length < length ? generateArray(length, arr) : arr ;}function toFlat(arr, newArr = []) {  for (let key in arr) {    console.log(arr[key])    typeof arr[key] === 'number' ? newArr.push(arr[key]) : toFlat(arr[key], newArr);  }  return Array.from(new Set(newArr)).sort((a, b) =>{ return a - b});}// class LazyMan {//   constructor(name) {//     this.name = name//     console.log(`Hi I am ${name}`)//   }//   sleep(time) {//     setTimeout(() => {//       console.log(`等待了${time}`)//     }, time)//   }//   eat(some) {//     console.log(`I am eating ${some}`)//   }// }function LazyMan(name) {  if(! (this instanceof  LazyMan)) {    return  new LazyMan(name)  }  this.taskList = [];  this.next();  console.log(`Hi I am ${name}`);}LazyMan.prototype.sleep = function(time) {  let that = this  that.taskList.push({    delayTime: time * 1000,    callback() {      console.log(`等待了${time}s ...`)      that.next()    }  })  return this;}LazyMan.prototype.eat = function(food) {  let that = this  that.taskList.push({    delayTime: 0,    callback() {      console.log(`I am eating ${food}`)      that.next()    }  })  return that;}LazyMan.prototype.next = function() {  const taskList = this.taskList;  if ( taskList.length === 0 ) return;  const {delayTime, callback} = taskList[0]  setTimeout(() => {    callback && callback()    taskList.shift()    this.next()  },delayTime)}LazyMan('Tony').sleep(10).eat('lunch');function add() {  let args = [].slice.call(arguments);  let addArgs = args.length === 1 ? args[0] : args.reduce((pre, item) => {    return pre + item  })  function sumF() {    let addArgs2 = args.length === 1 ? args[0] : args.reduce((pre, item) => {      return pre + item    })    return addArgs += addArgs2  }  sumF.toString = function () {    return addArgs  }  return sumF;}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/linkedList</title>
    <link href="/2021/03/17/algorithm/linkedList/"/>
    <url>/2021/03/17/algorithm/linkedList/</url>
    
    <content type="html"><![CDATA[/** * 链表——一种基础数据结构 * 自身就是一个指针，指向头结点，相应的这个头节点又有个指针指向下一个节点，以此类推。 * 每个节点包含两块区域，数据区域包含该位置的值，另一个区域包含一个指针指向下一个节点 */function LinkList() {    this._length = 0;  // 长度属性    this._head = null; // 链表指向的第一个元素，一开始的链表为空}LinkList.prototype = {    add: function(data) {        var node = {            data: data,            next: null        },        current;        if (this._head === null) {            this._head = node        } else {            current = this._head;            while (current.next) {                current = current.next            }            current.next = node        }        this._length++    },    item: function(index) {        if (index > -1 && index < this._length) {            var current = this._head,            i = 0;            while (i++ < index) {                current = current.next;            }            return current.data;        } else {            return null;        }    },    remove: function(index) {        if (index > -1 && index < this._length) {            var current = this._head,                previous,                i = 0;            if (index === 0) {                this._head = current.next            } else {                // 找到正确的位置进行删除                while (i++ < index) {                    previous = current;                    current = current.next                }                previous.next = current.next            }            this._length--;            return current.data;        } else {            return null;        }    }}// 使用var list = new LinkedList();list.add('red')list.add('orange')list.add('yellow')function showStudent(ssn) {    var student = db.get(ssn);    if(student !== null) {        document.querySelector(`#{elementId}`).innerHTML = `${student.ssn}, ${student.firstname}, ${student.lastname}`;    } else {        throw  new Error('student is not found')    }}var find = curry(function (db, id) {    var obj = bd.get(id);    if(obj === null) {        throw new Error('Object not found');    }    return obj;})var csv = (student) => {    return `${student.ssn}, ${student.firstname}, ${student.lastname}`;}var append = curry(function (elementId, info) {    document.querySelector(elementId).innerHTML = info;})var showStudent = run(append('#student-info'), csv, find(db));class Person {    constructor(firstname, lastname, ssn) {        this._firstname = firstname;        this._lastname = lastname;        this._ssn = ssn;        this._address = null;        this._birthYear = null;    }    get ssn() {        return this._ssn;    }    get firstname() {        return this._firstname;    }    get address() {        return this._address;    }    get birthYear() {        return this._birthYear;    }    set address(addr) {        this._address = addr;    }    toString() {        return `Person(${this._firstname}, ${this._lastname})`    }}class Student extends Person {    constructor(firtname, lastname, ssn, school) {        super(firtname, lastname, ssn);        this._school = school    }    get school() {        return this._school;    }}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/throttle</title>
    <link href="/2021/03/17/algorithm/throttle/"/>
    <url>/2021/03/17/algorithm/throttle/</url>
    
    <content type="html"><![CDATA[<p>##节流函数 throttle<br>###方案一</p><pre><code class="hljs plain">function throttle(fn, time) &#123;    let previous &#x3D; 0    return function(...args) &#123;        const temp &#x3D; +new Date();        if(temp - previous &gt; time) &#123;            previous &#x3D; temp;            fn.apply(this, args);        &#125;       &#125;&#125;</code></pre><h4 id="防抖函数-debounce"><a href="#防抖函数-debounce" class="headerlink" title="防抖函数 debounce"></a>防抖函数 debounce</h4><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><pre><code class="hljs plain">function debounce(fn, time)&#123;    let timer &#x3D; null;    return function(...args) &#123;        if(!timer) &#123;            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;                fn.call(this, args)            &#125;, time)           &#125;        clearTimeout(timer)    &#125;        &#125;</code></pre><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.race = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(promises.lenghth === <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        promises.forEach(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> &#123;            <span class="hljs-built_in">Promise</span>.resolve(promises[i]).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;                resolve(data);                <span class="hljs-keyword">return</span>;            &#125;, (err) =&gt; &#123;                reject(err)            &#125;)              &#125;)    &#125;)    &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端适配方案</title>
    <link href="/2021/03/17/css/mobile/"/>
    <url>/2021/03/17/css/mobile/</url>
    
    <content type="html"><![CDATA[<p>###像素</p><h4 id="物理像素（设备像素）"><a href="#物理像素（设备像素）" class="headerlink" title="物理像素（设备像素）"></a>物理像素（设备像素）</h4><p>屏幕的物理像素，又被成为设备像素，是现实设备中最微小的物理部件，任何设备的屏幕的物理像素出厂时就确定了，且固定不变</p><h4 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h4><p>设备独立像素也成为密度无关像素，可以认为是计算机坐标的一个点，这个点可以代表一个可由程序使用的虚拟像素（例如css像素），然后有相关系统转换为物理像素</p><h4 id="设备像素比（devicePixelRatio）"><a href="#设备像素比（devicePixelRatio）" class="headerlink" title="设备像素比（devicePixelRatio）"></a>设备像素比（devicePixelRatio）</h4><p>简称dpr ，定义了物理像素和设备独立像素的对应关50系</p><pre>设备像素比 = 物理像素 / 独立设备像素以iphone6 为例  设备固有像素为 750 * 1334，设备宽度是 375 * 667，其 dpr 就是2可以通过 window.devicePixelRatio 获得dpr > 1 就是高清屏，一般dpr为整数</pre><h4 id="css像素"><a href="#css像素" class="headerlink" title="css像素"></a>css像素</h4><p>css、js中使用的一个长度单位。单位 px</p><p>注意：pc端1物理像素 等于1px，但是移动端1物理像素不等于 1px，1物理像素与 px的关系与以下因素有关</p><pre>1.屏幕布局的视口大小2.屏幕的分辨率（物理像素）</pre><p>对于一块屏幕，其物理像素是确定的。视觉视口尺寸是继承与布局视口的，而视觉视口里的宽度即是css的px数。故一块屏幕上的物理像素与px的关系就是物理像素与布局视口的px数的关系</p><pre><code class="hljs plain">比如 iPhone6 它的物理像素是750px， 如果没有设置布局视口 viewport 为 980px此时: 1物理像素长度 &#x3D; 980px &#x2F; 750px &#x3D; 1.3076px 的长度由于像素都是点阵的 一个物理像素点相当度 1.3076px * 1.3076px 方格当在meta中设置了如下配置时 &lt;meta name &#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt; 相当于把布局视口设置为设备的宽度（即上面讲到的设备独立像素）， 对于iphone6就是375此时： 1物理像素长度 &#x3D; 375px &#x2F; 750px &#x3D; 0.5 的长度，相当于 0.5px * 0.5px 方格</code></pre><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><h4 id="1-布局视口"><a href="#1-布局视口" class="headerlink" title="1.布局视口"></a>1.布局视口</h4><p> 在html中一般在meta中的name为viewport 字段就是控制的布局视口，布局视口一般都是浏览器厂商给的一个值。但是浏览器厂商一般为了能小屏幕也能友好的展示，把布局视口设置很大，一般在768px~1024ox之间，最常用的就是980px。这样用户就能看大绝大部分的内容，根据内容去缩放</p><p> 故布局视口是看不见的，浏览器厂商设置的固定值，eg：980px，并将980px内容缩放到手机屏幕内</p><p> 布局视口可以通过</p><pre><code class="hljs plain">document.documentElement.clientWidth</code></pre><h4 id="2-视觉视口"><a href="#2-视觉视口" class="headerlink" title="2.视觉视口"></a>2.视觉视口</h4><p>浏览器可视区域的大小，即用户可以看到的区域。（其宽度继承于布局视口的宽度）</p><pre><code class="hljs plain">window.innerwidth</code></pre><h4 id="3-理想视口"><a href="#3-理想视口" class="headerlink" title="3.理想视口"></a>3.理想视口</h4><p>布局视口虽然解决了移动端 查看pc网页的问题，但是完全忽略的手机本身的尺寸。所以苹果引入了理想视口，它对于设备来说就是最理想的布局视口,用户不需要缩放就可以完美展示整个页面</p><p>可以通过</p><pre><code class="hljs plain">window.screen.width</code></pre><p>移动端到底如何适配呢 最简单就是设置如下视口</p><pre><code class="hljs plain">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,user-scalable&#x3D;no&quot;&gt;</code></pre><p>使用上述方案定义布局视时，即布局视口等于理想视口，屏幕没有滚动条，不存在高清屏下，字体较小的问题。但是在不同的屏幕上，视觉宽度是不同的，不能简单的将所有的尺寸都设置为px，</p><h4 id="viewport缩放"><a href="#viewport缩放" class="headerlink" title="viewport缩放"></a>viewport缩放</h4><p>对于上面设置，在不同的屏幕上，css像素对应的物理像素具体的数值是不一致的</p><p>在普通屏幕上 dpr = 1 时，<br>1个css像素长度对应一个物理像素长度，1个css像素对应一个物理像素</p><p>在retina屏幕， dpr = 2</p><p>1个css像素长度对应 2个物理像素长度， 一个css像素 对应 4个物理像素</p><h4 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h4><p>#####方案一<br>固定高度 宽度自适应</p><p>使用理想视口的方案</p><pre><code class="hljs plain">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minumum-scale&#x3D;1,user-scalable&#x3D;no&quot; &gt;</code></pre><p>垂直方向使用固定的值，水平方向使用弹性布局，元素使用定值 百分比 flex 布局</p><h5 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h5><p>固定布局视口宽度，使用viewport 缩放</p><pre><code class="hljs plain">if(&#x2F;Android (\d+\.\d+)&#x2F;.test(navigator.userAgent))&#123;  var version &#x3D; parseFloat(RegExp.$1);  if(version&gt;2.3)&#123;    var phoneScale &#x3D; parseInt(window.screen.width)&#x2F;640;    if(&#x2F;MZ-M571C&#x2F;.test(navigator.userAgent))&#123;      document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, minimum-scale &#x3D; 0.5, maximum-scale&#x3D; 0.5&quot;&gt;&#39;);    &#125;else if(&#x2F;M571C&#x2F;.test(navigator.userAgent)&amp;&amp;&#x2F;LizhiFM&#x2F;.test(navigator.userAgent))&#123;      document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, minimum-scale &#x3D; 0.5, maximum-scale&#x3D; 0.5&quot;&gt;&#39;);    &#125;else&#123;      document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, minimum-scale &#x3D; &#39;+ phoneScale +&#39;, maximum-scale &#x3D; &#39;+ phoneScale +&#39;, target-densitydpi&#x3D;device-dpi&quot;&gt;&#39;);    &#125;  &#125;else&#123;    document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, target-densitydpi&#x3D;device-dpi&quot;&gt;&#39;);  &#125;&#125;else&#123;  document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, user-scalable&#x3D;no, target-densitydpi&#x3D;device-dpi&quot;&gt;&#39;);&#125;</code></pre><p>方案三：</p><p>根据不同的屏幕动态写入font-size， 以rem作为宽度单位， 固定布局视口</p><pre><code class="hljs plain">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maxmum-scale&#x3D;1,user-scalable&#x3D;no&quot; &gt;</code></pre><p>以640px 设计稿 或者 750px 设计稿，</p><pre><code class="hljs plain">var width &#x3D; document.document.clientWidth;var rem &#x3D; width &#x2F; 7.5var rem width &#x2F; 6.4</code></pre><p>方案四 </p><p>以rem作为宽度单位，动态写入viewport 和 font-size 进行缩放</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http/http</title>
    <link href="/2021/03/17/http/http/"/>
    <url>/2021/03/17/http/http/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP-简介"><a href="#HTTP-简介" class="headerlink" title="HTTP 简介"></a>HTTP 简介</h2><p><strong>HTTP</strong><br>超文本传输协议，主要规定浏览器和服务器相互通信规则，它是基于TCP/IP通信协议来进行传递数据。对于<br>TCP协议来说，TCP协议是一套双向通讯通道，HTTP在TCP的基础上规定了Request和Reponse的模式。这个模式<br>决定了通讯必定是有浏览器发起的。<br>浏览器发起http请求， 首先建立TCP连接  也就是常说的三次握手， 接下来发起Http请求<br>一个http请求主要包括 请求行 请求头 请求正文</p><h5 id="请求行：请求地址、请求的方法（get，-post、put、delete）、请求状态"><a href="#请求行：请求地址、请求的方法（get，-post、put、delete）、请求状态" class="headerlink" title="请求行：请求地址、请求的方法（get， post、put、delete）、请求状态"></a>请求行：请求地址、请求的方法（get， post、put、delete）、请求状态</h5><ul><li>2** 成功<br>#excerpt_link: Read More…</li><li>3** 重定向<br>  301 永久重定向<br>  302 临时重定向<br>  304 not modify</li><li>4** 客户端错误<br>  400 Bad request 请求中有语法错误<br>  401 Unauthorize 未被授权<br>  403 forbidden 禁止访问<br>  404 Not found 请求的页面不存在</li><li>5** 服务端请求错误<br>  500 服务端错误<br>  503 service unavailable<h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5>Accept<br>host<br>UserAgent<br>cookie （key value domin expires size httponly）4k 最多可以有20个 默认到浏览器关闭<br>connection keep-alive<h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5>http 响应请求<br>响应行<br>响应体<br>cache-control<br>content-type<br>status<br>expires<br>date<br>Last-Modified<br>结束<br>断开 TCP 连接 四次挥手<h2 id="HTTPS-http-ssl"><a href="#HTTPS-http-ssl" class="headerlink" title="HTTPS = http + ssl"></a>HTTPS = http + ssl</h2>HTTPS 是使用加密通道来传输HTTP的内容，但是HTTPS首先与服务端建立一条TLS加密通道。TLS构于TCP协议之上对内容做一个次加密，<br>所以他主要有两个作用</li><li>确定请求目标服务器的身份</li><li>保证传输的数据不会被网络中间节点窃听或篡改<h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2>是HTTP1.1的升级版本， 最大的改进点是</li><li>支持服务端推送<br>服务端推送能够在客户端发送第一个请求到达服务端时，提前把一部分内容推送客户端，放入缓存之中，避免客户端请求顺序带来的并行度不高，<br>从而导致性能问题</li><li>支持TCP连接复用<br>TCP连接复用，则使用TCP连接来传输多个HTTP请求，避免TCP连接建立时的三次握手开销和初建TCP连接的传输窗口小的问题</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>prototype/this</title>
    <link href="/2021/03/17/prototype/this/"/>
    <url>/2021/03/17/prototype/this/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise 详解</title>
    <link href="/2021/03/17/promise/1/"/>
    <url>/2021/03/17/promise/1/</url>
    
    <content type="html"><![CDATA[<p>new Promise时， 需要传递一个 executor 执行器， 执行器立即执行</p><a id="more"></a><p>/**</p><ul><li><ol><li>new Promise时， 需要传递一个 executor 执行器， 执行器立即执行</li></ol></li><li><ol start="2"><li>executor 接受两个参数 分别是 resolve 和 reject</li></ol></li><li><ol start="3"><li>promise 只能从 pending 到 rejected， 或者 从 pending 到 resolved</li></ol></li><li><ol start="4"><li>promise 的状态一旦确认， 就不会再改变</li></ol></li><li><ol start="5"><li>promise 都有 then 方法， then方法接收两个参数， </li></ol></li><li>分别是 promise 成功回调的 onFulfilled 和 失败回调的 onRejected</li><li><ol start="6"><li>如果调用 then 时，promise已经成功，则执行 onFulfilled 并将 promise的值作为参数传进去</li></ol></li><li>如果promise已经失败， 那么执行 onRejected 并将 promise失败的原因作为参数传递进去</li><li>如果promise是pending状态，则把 onFulfilled 和 onRejected 函数存起来， 等到状态确定后，</li><li>再按照相应的对象执行（发布-订阅模式）</li><li><ol start="7"><li>onFulfilled 和 onRejected 的参数可以缺省</li></ol></li><li><ol start="8"><li>promise 可以 then 多次，promise的then 返回一个promise</li></ol></li><li><ol start="9"><li>如果then返回的是一个结果， 那么可以把这个结果作为参数，传递下一个then 的 onFulfilled成功的回调</li></ol></li><li><ol start="10"><li>如果then 返回的是一个异常， 那么可以把这个异常作为参数， 传递给下一个then 的 onRejected 失败回调</li></ol></li><li><ol start="11"><li>如果 then 返回的是一个promise, 那么需要等这个promise 那么等到这个promise 执行完</li></ol></li><li>promise执行成功就走下一个then成功， promise执行失败就走下一个then的失败</li><li>/</li></ul><p>``` js<br>const PENDING = “pending”;<br>const FULFILLED = “fulfilled”;<br>const REJECTED = ‘rejected’;</p><p>function Promise(excutor) {<br>  let that = this; //缓存当前promise 实例对象<br>  that.status = PENDING; // 初始状态<br>  that.value = undefined; // fulfilled状态时 返回的信息<br>  that.reason = undefined; // rejected状态时 拒绝的原因<br>  that.onFulfilledCallbacks = []; //存储fulfilled 状态对应的onFulfilled函数<br>  that.onRejectedCallbacks = []; //存储rejected 状态对应的onRejected 函数</p><p>  function resovle (value) { //value 成功态时接受的终值<br>    if(value instanceof Promise) {<br>      return value.then(resovle, reject)<br>    }<br>    //实践中要确保 onFulfilled 和 onRejected方法异步执行，<br>    //且应该在then 方法调用的时候那一轮事件循环的执行栈执行结束之后<br>    setTimeout(() =&gt; {<br>      // 调用resovle 回调对应的onFulfilled函数<br>      if (that.status === PENDING) {<br>        // 只能由pending状态 =》 fulfilled 状态（避免多次调用resovle reject）<br>        that.status = FULFILLED;<br>        that.value = value;<br>        that.onFulfilledCallbacks.forEach(callback =&gt; {<br>          callback(that.value)<br>        });<br>      }<br>    })<br>  }</p><p>  function reject(reason) {<br>    setTimeout(() =&gt; {<br>      // 调用reject 回调对应onRejected 函数<br>        if (that.status === PENDING) {<br>          // 只能由 pending =》 rejected （避免多次调用resovle reject）<br>          that.status = REJECTED;<br>          that.reason = reason;<br>          that.onRejectedCallbacks.forEach(callback =&gt; {<br>            callback(that.reason)<br>          })<br>        }<br>    })<br>  }</p><p>  //捕获在excutor执行期炮数的异常<br>  try {<br>    excutor(resovle, reject)<br>  } catch (error) {<br>    reject(e)<br>  }<br>}</p><p>Promise.prototype.then = function(onFulfilled, onRejected) {<br>  const that = this;<br>  let newPromise;<br>  onFulfilled =<br>    typeof onFulfilled === “function” ? onFulfilled : value =&gt; value;<br>  onRejected =<br>   typeof onRejected === “function” ? onRejected : reason =&gt; {<br>     throw reason<br>   }</p><p>   if(that.status === FULFILLED) {<br>     return newPromise = new Promise((resovle, reject) =&gt; {<br>       setTimeout(() =&gt; {<br>         try {<br>           let x = onFulfilled(that.value)<br>           resovlePromise(newPromise, x, resovle, reject);<br>         } catch (error) {<br>           reject(error)<br>         }<br>       })<br>     })<br>   }</p><p>   if(that.status === REJECTED) {<br>     return newPromise = new Promise(() =&gt; {<br>       setTimeout(() =&gt; {<br>         try {<br>           let x = onRejected(that.reason)<br>           resovlePromise(newPromise, x, resovle, reject)<br>         } catch (error) {<br>           reject(error)<br>         }<br>       })<br>     })<br>   }</p><p>   if(that.status === PENDING) {<br>     that.onFulfilledCallbacks.push(() =&gt; {<br>        setTimeout(() =&gt; {<br>          try {<br>            let x = onFulfilled(that.value)<br>            resovlePromise(newPromise, x, resovle, reject)<br>          } catch (error) {<br>            reject(error)<br>          }<br>        })<br>     })</p><pre><code>that.onRejectedCallbacks.push(() =&gt;{  setTimeout(() =&gt; {    try {      let x = onRejected(that.reason)      resovlePromise(newPromise, x, resovle, reject)    } catch (error) {      reject(error)    }  })})</code></pre><p>  }</p><p>}</p><p>function resolvePromise (newPromise, x, resolve, reject) {<br>  let that = this;<br>  if(newPromise === x) {<br>    reject(new TypeError(‘Chaining cycle’));<br>  }<br>  if(x &amp; typeof x === ‘object’ || typeof x === ‘function’) {<br>    let used;<br>    try {<br>      let then = x.then;<br>      if(typeof then === ‘function’) {<br>        then.call(x, (y) =&gt; {<br>          if(used) return;<br>          used === true;<br>          resovlePromise(newPromise, y, resolve, reject);<br>        }, (reason) =&gt; {<br>          if(used) return;<br>          used === true;<br>          reject(reason);<br>        })<br>      }else {<br>        if(used) return;<br>        used = true;<br>        resolve(x);<br>      }<br>    } catch (error) {<br>      if(used) return;<br>      used = true;<br>      reject(error);<br>    }<br>  }else{<br>    resolve(x);<br>  }<br>}</p><p>// promise.finally<br>// 不管成功 or 失败 最终都会走到finally 还可以继续 then 且可以把值原封不动的传给后面的then<br>Promise.prototype.finally = function (callback) {<br>  return this.then((value) =&gt; {<br>    return Promise.resolve(callback()).then(() =&gt; {<br>      return value<br>    })<br>  }, (err) =&gt; {<br>    return Promise.resolve(callback().then(() =&gt; {<br>      throw err<br>    }))<br>  })<br>}</p><p>//promise.all（promises） 返回一个promise对象<br>/**</p><ul><li><ol><li>如果传入的是一个空的可迭代对象，那么此promise对象回调完成（resolve），</li></ol></li><li><p>只有这种情况是同步执行的，其他的都是返回一个异步完成</p></li><li><ol start="2"><li>如果传入参数不包含任何一个promise， 则返回一个异步完成</li></ol></li><li><ol start="3"><li>promises 所有的promise都完成时，或参数中不包含promise时 回调完成</li></ol></li><li><ol start="4"><li>如果一个 promise 失败，那么promise.all 返回的promise对象失败</li></ol></li><li><ol start="5"><li>在任何情况下，promises返回的promise的完成状态结果都是一个数组</li></ol></li><li><p>/</p><p>Promise.prototype.all = function (promises) {<br> return new Promise((resolve, rejected) =&gt; {<br>  let index = 0;<br>  let result = [];<br>  if (promises.length === 0) {</p><pre><code>resolve(result);</code></pre><p>  } else {</p><pre><code>function processValue (idx, data) {  result[i] = data;  if (++index === promises.length) {    resolve(result)  }}for (let i = 0; i &lt; promises.length; i++) {  //promises[i]可能是个普通值  Promise.resolve(promises[i]).then((data) =&gt; {    processValue(i, data)  }, (err) =&gt; {    rejected(err);    return;  })}</code></pre><p>  }<br> })<br>}</p></li></ul><p> //Promise.race()<br> /**</p><ul><li>返回一个promise函数，他将与第一个传递的promise相同的方式被完成，他可以是完成也可以是失败，</li><li>取决于第一个完成的方式是两个中的哪一个</li><li>如果传递的是一个空数组，那么primise将处于永远等待</li><li>如果迭代中包含一个或多个 非promise/resolve/reject的promise，那么promise.race将解析为迭代中找到的第一个值</li><li>/<br>Promise.prototype.race = function(promises) {<br>return new Promise((resovle, reject) =&gt; {<br> if(promises.length === 0) {<br>   return;<br> }else {<br>   for (let i = 0; i &lt; promises.length; i++) {<pre><code>Promise.resolve(promises[i]).then((data)=&gt; {  resolve(data);  return;}, (err) =&gt; {  reject(err);  return;})</code></pre>   }<br> }<br>})<br>}</li></ul><p>//Promise.allSettled<br>/**</p><ul><li><p>将一组promise实例作为参数，包装成一个新的promise实例，只有等到所有的promise都执行完成后</p></li><li><p>不管是fulfilled 或是 rejected 包装实例才会结束</p></li><li><p>/</p><p>//Promise.any<br>/**</p></li><li><p>将一组promise实例作为参数，包装成一个新的promise实例，实例参数只要有一个promise是resolve状态</p></li><li><p>包装的实例则返回resolve状态，如果实例参数都返回rejected状态，实例才返回 rejected</p></li><li><p>/</p></li></ul><p>// 防抖<br>function debounce(fn, wait) {<br>  let timer = null;<br>  return function (…args) {<br>    if(timer) clearTimeout(timer)<br>    timer = setTimeout(() =&gt; {<br>      fn.apply(this, args)<br>    }, wait)<br>  }<br>}</p><p>// 节流<br>function throttle(fn, wait) {<br>  let previous = 0;<br>  return function(…args) {<br>    let now = +new Date();<br>    if(now - previous) {<br>      previous = now;<br>      fn.apply(this, args)<br>    }<br>  }<br>}</p><p>var value = 2;<br>var foo = {<br>  value: 1<br>};</p><p>function bar(name, age) {<br>  return {<br>    value: this.value,<br>    name: name,<br>    age: age<br>  }<br>}<br>bar.call(foo, ‘Jack’, ‘20)</p><p>Function.prototype.bind = function(context) {<br>  if(typeof this !== “function”) {<br>    throw new Error(‘)<br>  }<br>  let self = this;<br>  var args = Array.prototype.slice.call(arguments, 1)<br>  const fBind = function() {<br>     var bindArgs = Array.prototype.slice.call(arguments)<br>     return self.apply(this instanceof fBind ? this : context, args.concat(bindArgs))<br>  }<br>  var fNOP = function () {};<br>  fNOP.prototype = this.prototype;<br>  fBind.prototype = new fNOP();<br>  return fBind;<br>}</p><p>Function.prototype.myNew = function() {<br>  let ctor = [].shift.call(arguments);</p><p>  let obj = Object.create(ctor.prototype);</p><p>  let result = ctor.apply(obj, arguments);</p><p>  return result instanceof Object ? result : obj;<br>}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react/QA</title>
    <link href="/2021/03/17/react/QA/"/>
    <url>/2021/03/17/react/QA/</url>
    
    <content type="html"><![CDATA[<h3 id="常见问题QA"><a href="#常见问题QA" class="headerlink" title="常见问题QA"></a>常见问题QA</h3><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><h5 id="React-合成事件"><a href="#React-合成事件" class="headerlink" title="React 合成事件"></a>React 合成事件</h5><p>React 合成事件（SyntheticEvent）<br>是 React 模拟原生 DOM 事件所有能力的一个自定义事件对象，可以理解为浏览器原生事件的跨浏览器包装器。<br>它根据 W3C 规范 来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口。合成事件的原理是利用事件冒泡，通过 事件委托 把事件统一在<br> document 这个 DOM 节点上。<br>React事件系统<br> 涉及到的主要类如下<br>ReactEventListener：负责事件注册和事件分发。React将DOM事件全都注册到document这个节点上，这个我们在事件注册小节详细讲。事件分发主要调用dispatchEvent进行，从事件触发组件开始，向父元素遍历。我们在事件执行小节详细讲。<br>ReactEventEmitter：负责每个组件上事件的执行。<br>EventPluginHub：负责事件的存储，合成事件以对象池的方式实现创建和销毁，大大提高了性能。<br>SimpleEventPlugin等plugin：根据不同的事件类型，构造不同的合成事件。如focus对应的React合成事件为SyntheticFocusEvent</p><ul><li>React组件上声明的事件最终绑定到了document这个DOM节点上，而不是React组件对应的DOM节点。故只有document这个节点上面才绑定了DOM原生事件，<br>其他节点没有绑定事件。这样简化了DOM原生事件，减少了内存开销</li><li>React以队列的方式，从触发事件的组件向父组件回溯，调用它们在JSX中声明的callback。也就是React自身实现了一套事件冒泡机制。</li><li>React有一套自己的合成事件SyntheticEvent，不同类型的事件会构造不同的SyntheticEvent</li><li>React使用对象池来管理合成事件对象的创建和销毁，这样减少了垃圾的生成和新对象内存的分配，大大提高了性能<h5 id="React-v16-解决了什么问题"><a href="#React-v16-解决了什么问题" class="headerlink" title="React v16 解决了什么问题"></a>React v16 解决了什么问题</h5>答：React 16 以前，在协调阶段阶段，由于是采用的递归的遍历方式，这种也被成为 Stack Reconciler。<br>这种方式有一个特点：一旦任务开始进行，就无法中断，那么 js 将一直占用主线程， 一直要等到整棵 Virtual DOM 树计算完成之后，<br>才能把执行权交给渲染引擎，那么这就会导致一些用户交互、动画等任务无法立即得到处理，就会有卡顿，非常的影响用户体验。<br>React 16，实现状态更新机制，支持不同任务的优先级，可中断和恢复，并且恢复后可复用之前的中间状态<h5 id="React-Fiber-是什么"><a href="#React-Fiber-是什么" class="headerlink" title="React Fiber 是什么"></a>React Fiber 是什么</h5>答： React Fiber 是一种基于浏览器的单线程调度算法<br>React Fiber 用类似<code>requestIdleCallback</code> 的机制来做异步 diff。但是之前数据结构不支持这样的实现异步 diff，<br>于是 React 实现了一个类似链表的数据结构，将原来的 递归diff 变成了现在的 遍历diff，这样就能做到异步可更新了。<h5 id="聊一聊diff"><a href="#聊一聊diff" class="headerlink" title="聊一聊diff"></a>聊一聊diff</h5></li><li>tree diff 只对比同一层的 dom 节点，忽略 dom 节点的跨层级移动</li><li>component diff：如果不是同一类型的组件，会删除旧的组件，创建新的组件</li><li>element diff：对于同一层级的一组子节点，需要通过唯一 id 进行来区分<h5 id="setState-的-同步异步"><a href="#setState-的-同步异步" class="headerlink" title="setState 的 同步异步"></a>setState 的 同步异步</h5></li><li>合成事件中是异步</li><li>钩子函数中的是异步</li><li>原生事件中是同步</li><li>setTimeout中是同步<h5 id="setState-之后发生了什么"><a href="#setState-之后发生了什么" class="headerlink" title="setState 之后发生了什么"></a>setState 之后发生了什么</h5></li><li>在 setState 的时候，React 会为当前节点创建一个 updateQueue 的更新列队。</li><li>然后会触发 reconciliation 过程，在这个过程中，会使用名为 Fiber 的调度算法，开始生成新的 Fiber 树</li><li>然后 React Scheduler 会根据优先级高低，先执行优先级高的节点，具体是执行 doWork 方法。</li><li>在 doWork 方法中，React 会执行一遍 updateQueue 中的方法，以获得新的节点。然后对比新旧节点，为老节点打上 更新、插入、替换 等 Tag。</li><li>当前节点 doWork 完成后，会执行 performUnitOfWork 方法获得新节点，然后再重复上面的过程。</li><li>当所有节点都 doWork 完成后，会触发 commitRoot 方法，React 进入 commit 阶段。</li><li>在 commit 阶段中，React 会根据前面为各个节点打的 Tag，一次性更新整个 dom 元素。<h6 id="React有哪些优化性能的手段"><a href="#React有哪些优化性能的手段" class="headerlink" title="React有哪些优化性能的手段?"></a>React有哪些优化性能的手段?</h6>1、类组件中的优化手段</li><li>使用纯组件 pureComponent</li><li>使用React.memo 高阶函数包装组件</li><li>使用shouldComponentUpdate 生命周期函数来自定义渲染逻辑</li></ul><p>2.其他方式</p><ul><li>列表中使用key</li><li>使用Suspense 和 lazy 进行懒加载<h6 id="什么是suspense组件"><a href="#什么是suspense组件" class="headerlink" title="什么是suspense组件"></a>什么是suspense组件</h6>Suspense 让组件“等待”某个异步操作，直到该异步操作结束即可渲染。<h6 id="react-redux-的实现原理？"><a href="#react-redux-的实现原理？" class="headerlink" title="react-redux 的实现原理？"></a>react-redux 的实现原理？</h6>通过 redux 和 react context 配合使用，并借助高阶函数，实现了 react-redux。<h5 id="react组件逻辑复用的几种方式"><a href="#react组件逻辑复用的几种方式" class="headerlink" title="react组件逻辑复用的几种方式"></a>react组件逻辑复用的几种方式</h5></li><li>Render props<br><code>render props</code>指在一种React组件之间使用一个值为函数的props共享代码的简单技术，具有render props的组件接收一个函数，该函数返回一个React元素并调用它而不是实现一个自己的渲染逻辑，render props是一个用于告知组件需要渲染什么内容的函数props，也是组件逻辑复用的一种实现方式，简单来说就是在被复用的组件中，通过一个名为render(属性名也可以不是render，只要值是一个函数即可)的prop属性，该属性是一个函数，这个函数接受一个对象并返回一个子组件，会将这个函数参数中的对象作为props传入给新生成的组件，而在使用调用者组件这里，只需要决定这个组件在哪里渲染以及该以何种逻辑渲染并传入相关对象即可</li><li>mixin</li><li>HOC<br>属性代理<br>反向继承</li><li>Hook<h5 id="react-router-原理"><a href="#react-router-原理" class="headerlink" title="react-router 原理"></a>react-router 原理</h5>三个API的大致的技术实现如下:</li><li>createBrowserHistory: 利用HTML5里面的history</li><li>createHashHistory: 通过hash来存储在不同状态下的history信息</li><li>createMemoryHistory: 在内存中进行历史记录的存储<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><h5 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h5><h5 id="浏览器渲染原理（从url输入到返回请求的过程）"><a href="#浏览器渲染原理（从url输入到返回请求的过程）" class="headerlink" title="浏览器渲染原理（从url输入到返回请求的过程）"></a>浏览器渲染原理（从url输入到返回请求的过程）</h5></li><li>首先进行url解析，根据dns系统进行IP查找（迭代查找）<ul><li>首先检查hosts文件是否有记录 有返回对应的ip</li><li>hosts文件没有检查本地的dns解析器有无缓存 有返回</li><li>计算机上配置DNS服务器是否有缓存 有返回</li><li>然后就去找根DNS服务器，直到查到域名对应的IP地址</li></ul></li><li>建立TCP链接，HTTP协议的三次握手<ul><li>1) 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li><li>2）服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li><li>3) 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li></ul></li><li>请求html文件了，如果html文件在缓存里面浏览器直接返回<ul><li>构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；</li><li>解析图片、CSS、JavaScript脚本等资源，这些资源是需要从网络或者缓存中获取，浏览器会逐一发起请求获取</li><li>构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；</li><li>执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）</li><li>构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；</li><li>渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。</li><li>布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；</li><li>绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；</li></ul></li><li>断开连接：TCP 四次挥手<ul><li>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li><li>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li><li>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li><li>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。</li></ul></li></ul><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><h5 id="webpack-流程细节"><a href="#webpack-流程细节" class="headerlink" title="webpack 流程细节"></a>webpack 流程细节</h5><p>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；<br>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；<br>确定入口：根据配置中的 entry 找出所有的入口文件；<br>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；<br>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；<br>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；<br>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p><h5 id="webpack-中，module，chunk-和-bundle-的区别是什么？"><a href="#webpack-中，module，chunk-和-bundle-的区别是什么？" class="headerlink" title="webpack 中，module，chunk 和 bundle 的区别是什么？"></a>webpack 中，module，chunk 和 bundle 的区别是什么？</h5><ul><li><ol><li>对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 module ；</li></ol></li><li><ol start="2"><li>当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这个 chunk 文件进行一些操作；</li></ol></li><li><ol start="3"><li>webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。<h5 id="webpack-中，hash、chunkhash、contenthash-有什么不同？"><a href="#webpack-中，hash、chunkhash、contenthash-有什么不同？" class="headerlink" title="webpack 中，hash、chunkhash、contenthash 有什么不同？"></a>webpack 中，hash、chunkhash、contenthash 有什么不同？</h5></li></ol></li><li><ol><li>hash 计算是跟整个项目的构建相关</li></ol></li><li><ol start="2"><li>它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。</li></ol></li><li><ol start="3"><li>将根据资源内容创建出唯一 hash，也就是说文件内容不变，hash 就不变。<h5 id="Webpack-自动刷新"><a href="#Webpack-自动刷新" class="headerlink" title="Webpack 自动刷新"></a>Webpack 自动刷新</h5></li></ol></li><li>webpack负责文件监听<br>在 Webpack 中监听一个文件发生变化的原理是定时的去获取这个文件的最后编辑时间，每次都存下最新的最后编辑时间，如果发现当前获取的和最后一次保存<br>的最后编辑时间不一致，就认为该文件发生了变化。 配置项中的 watchOptions.poll 就是用于控制定时检查的周期，具体含义是每隔多少毫秒检查一次。<br>当发现某个文件发生了变化时，并不会立刻告诉监听者，而是先缓存起来，收集一段时间的变化后，再一次性告诉监听者。<br>配置项中的 watchOptions.aggregateTimeout 就是用于配置这个等待时间。</li><li>webpack 模块会在文件发生变化时告诉 webpack-dev-server 模块。<br>webpack-dev-sever 负责刷新浏览器<ul><li>控制浏览器刷新有三种方法：<br>  1.借助浏览器扩展去通过浏览器提供的接口刷新，WebStorm IDE 的 LiveEdit 功能就是这样实现的。<br>  2.往要开发的网页中注入代理客户端代码，通过代理客户端去刷新整个页面。<br>  3.把要开发的网页装进一个 iframe 中，通过刷新 iframe 去看到最新效果。<h5 id="Webpack-HMR-原理"><a href="#Webpack-HMR-原理" class="headerlink" title="Webpack HMR 原理"></a>Webpack HMR 原理</h5></li></ul></li><li>注入一个代理客户端用于连接 DevServer 和网页<h5 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h5>Tree Shaking 可以用来剔除 JavaScript 中用不上的死代码。它依赖静态的 ES6 模块化语法。Webpack 只是指出了哪些函数用上了哪些没用上，要剔除用不上<br>的代码还得经过 UglifyJS 去处理一遍。 要接入 UglifyJS 也很简单，<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react/fiber</title>
    <link href="/2021/03/17/react/fiber/"/>
    <url>/2021/03/17/react/fiber/</url>
    
    <content type="html"><![CDATA[function FiberNode (    tag: WorkTag,    pendingProps: mixed,    key: null | string,    mode: TypeOfMode) { // 作为静态数据结构的属性    this.tag = tag; // 对应的组件类型 Function/Class/Host    this.key = key; // key 属性    this.elementType = null; //大部分情况相同，某些情况不同，比如FunctionComponent使用React.memo 包裹    this.type =null; // 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName    this.stateNode = null; // Fiber对应的真实Dom节点    //用于连接其他fiber节点形成Fiber树    // 指向父节点    this.return = null;    // 指向子fiber节点    this.child = null;    // 指向右边第一个兄弟Fiber节点    this.sibling = null;    this.index = 0;    this.ref = null;    // 作为动态的工作单元的属性    // 保存本次更新造成的状态改变相关信息    this.pendingProps = pendingProps;    this.memorizedProps = null;    this.updateQueue = null;    this.memorizedState = null;    this.dependencies = null;    this.mode = mode;    this.effectTag = NoEffect;    this.nextEffect = null;    // 保存本次更新会造成的DOM操作    this.firstEffect = null;    this.lastEffect = null;    // 调度优先级相关    this.lanes = NoLanes;    this.childLanes = NoLanes;    // 指向该fiber在另一次更新时对应的fiber    this.alterate = null}function beginWork(    current: Fiber | null,    workInProgress: Fiber | null,    renderLanes: Lanes) : Fiber | null {    // update时，如果current存在可能会有优化路径， 可能复用current    if (current !== null) {        const oldProps = current.memorizedProps;        const newProps = current.pendingProps;        if (oldProps !== newProps ||            hasLegacyContentChanged() ||            (__DEV__ ? workInProgress.type !== current.type : false)        ) {            didReceiveUpdate = true;        } else if (!includesSomeLanes(renderLanes, updateQueue)) {            didReceiveUpdate = false;            switch (workInProgress) {                // 省略处理            }        } else {            didReceiveUpdate = false;        }        return bailoutOnAlreadyFinishedWork(            current,            workInProgress,            renderLanes        )    } else {        didReceiveUpdate = false;    }    // mount时：根据不同的tag类型创建不同的Fiber类型    switch(workInProgress.tag) {        case IndeterminateComponent:            // 省略        case LazyComponent:            // 省略        case ClassComponent:            // 省略        case FunctionComponent:            // 省略        case ClassComponent:            // 省略        case HostRoot:            // 省略        case HostComponent:            // 省略        case HostTest:    }     }export function reconcileChildren (    current: Fiber | null,    workInProgress: Fiber,    nextChildren: any,    renderLanes: Lanes) {    if(current === null) {        // 对于mount的组件        workInProgress.child = mountChildFibers(            workInProgress,            null,            nextChildren,            renderLanes        )    } else {        // 对于update的组件        workInProgress.child = reconcileChildrenFibers(            workInProgress,            current.child,            nextChildren,            renderLanes        )    }}function completeWork(    current: Fiber | null,    workInProgress: Fiber,    renderLanes: Lanes) : Fiber | null {    const newProps = workInProgress.pendingProps;    switch (workInProgress.tag) {        case HostComponent: {            popHostContext(workInProgress);            const rootContainerInstance = getRootHostContainber();            const type = workInProgress.type;            // 判断该Fiber节点是否存在的对应的DOM节点            if (current !== null && workInProgress.stateNode !== null) {                // update 的情况                updateHostComponent(                    current,                    workInProgress,                    type,                    newProps,                    rootContainerInstance                )            } else {                // mount 的情况                const currentHostContext = getHostContext();                // 为fiber创建对应的DOM的节点                const instance = createInstance(                    type,                    newProps,                    rootContainerInstance,                    currentHostContext,                    workInProgress                );                // 将子孙DOM节点插入刚生成的DOM节点中                appendAllChildren(instance, workInProgress, false, false);                // DOM节点赋值给fiber.stateNode                workInProgress.stateNode = instance;                //与update逻辑中updateHost类似处理props的过程                if(                    finallyInitialChidren(                        instance,                        type,                        newProps,                        rootContainerInstance,                        currentHostContext                    )                ) {                    markUpdate(workInProgress);                }            }        }    }}const update: Update<*> = {    eventTime,    lane,    suspenseConfig,    tag: UpdateState, // 更新的类型，包括UpdateState， ReplaceStae, ForceUpdate, CaptureUpdate    payload: null, // 更新挂载数据，不同类型组件挂在数据不一样， 对于ClassComponent, payload 为setState的第一个传参    callback: null    next: null}const queue: UpdateQueue<State> = {    baseState: fiber.memorizedState, // 本次更新前该Fiber节点的State， Update基于该State计算更新后的state    firstBaseUpdate: null, // 本次更新前该Fiber节点已经保存的Update。以链表形式存在，链表头为firstBaseUpdate，    lastBaseUpdate: null, // 链表尾为lastBaseUpdate， 之所以产生该Fiber节点内就存在Update，是由于某些Update优先级较低 所以在上次render阶段由Update计算被跳过    shared: {        pending: null // 触发更新时，产生的Update会保存在share.pending 中形成单项环状链表。当由Update计算state时这个环会被剪开并链接在lastBaseUpdate后面    },    effects: null}export function createFiberRoot (    containerInfo: any,    tag: RootTag,    hydrate: Boolean,    hydrationCallback: null | SuspenseHydrationCallbacks,): FiberRoot {    // 创建fiberRootNode    const root: Fiber = (new FiberRootNode(containerInfo, tag, hydrate): any);    // 创建rootFiber    const uninitailizedFiber = createHostRootFiber(tag);    // 链接rootFiber和fiberRootNode    root.current= uninitalizedFiber;    uninitalizedFiber.stateNode = root;    return root;}function dispatchAndLog(store, action) {    console.log('dispatching', action);    store.dispatch(addTdo('Use Redux'));    console.log('next state', store.getState());}const next = store.dispatchstore.dispatch = function dispatchAndLog(action) {    console.log('dispatching', action);    let result = next(action);    console.log('next state', store.getState());    return result;}function patchStoreToAddLogging(store) {    const next = store.dispatch    // store.dispatch = function dispatchAndLog(action) {    //     console.log('dispatching', action);    //     let result = next(action);    //     console.log('next state', store.getState());    //     return result;    // }    return function dispatchAndLog() {        console.log('dispatching', action);        let result = next(action);        console.log('next state', store.getState());        return result;    }}function patchStoreToAddCrashReporting(store) {    const next = store.dispatch    store.dispatch = function dispatchAndReportErrors(action) {        try {            return next(action)        } catch (err) {            console.log('捕获一个error', err);            Raven.captureException(err, {                extra: {                    action,                    state: store.getState()                }            })            throw err;        }    }}function applyMiddlewareByMonkeyPatch(store, middlewares) {    middlewares = middlewares.slice();    middlewares.reverse();    let dispatch = store.dispatch    middlewares.forEach(middleware => {        store.dispatch = middleware(store)(dispatch)    })    return Object.assign({}, store, {dispatch})}function logger(store) {    return function warpDsipatchToAddLogging(next) {        return function dispatchAndLog(action) {            console.log('dispatching');            let result = next(action);            console.log('next state', store.getState());            return result;        }    }}const logger = store => next => action => {    console.log('dispatching');    let result = next(action);    console.log('next state', store.getState());    return result;}/** * @param {string} s * @return {number} */var romanToInt = function(s) {    const map = {        I : 1,        IV: 4,        V: 5,        IX: 9,        X: 10,        XL: 40,        L: 50,        XC: 90,        C: 100,        CD: 400,        D: 500,        CM: 900,        M: 1000    };    let ans = 0;    for(let i = 0;i < s.length;) {        if(i + 1 < s.length && map[s.substring(i, i+2)]) {            ans += map[s.substring(i, i+2)];            i += 2;        } else {            ans += map[s.substring(i, i+1)];            i ++;        }    }    return ans;};const path = require('path');module.exports = {    entry: './src/index.js',    output: {        path: 'd',        filename: 'main.js'    }}const fs = require('fs');const path = require('path')const parser = require('@babel/parser');const options = require('webpack.config')const traverse = require('@babel/traverse').defautconst { transformFromAst } = require('@babel/core')const Parse = {    getAst: path => {        // 读取入口文件        const content = fs.readFileSync(path, 'utf-8');        // 将文件内容转换为AST抽象语法树        return parser.parser(content, {            sourceType: 'moudle'        })    },    getDependecies: (ast, filename) => {        const dependencies = {};        // 遍历所有的import模块，存入dependecies        traverse(ast, {            // 类型为ImportDeclaration的AST节点（即为import语句)            ImportDecalaration({ node }) {                const dirname = path.dirname(filename);                // 保存依赖模块路径，之后生成依赖关系图需要用到                const filepath = './' + path.join(dirname, node.source.value);                dependencies[node.source.value] = filepath;            }        })        return dependencies;    },    getCode: ast => {        const { code } = transformFromAst(ast, null, {            presets: ['@babel/preset-env']        })        return code;    }}class Compiler {    constructor(options) {        const { entry, output } = options;        // 入口        this.entry = entry;        // 出口        this.output = output;        // 模块        this.moudles = [];    }    // 构建启动    run() {        const info = this.build(this.entry);        this.modules.push(info)        this.modules.forEach((dependencies) => {            // 判断是否有依赖项递归 解析所有的依赖项            if(dependencies) {                for(const dependency in dependencies) {                    this.modules.push(this.build(dependency))                }            }        })        // 生成依赖关系图        const dependencyGraph = this.module.reduce((graph, item)= ({            ...graph,             // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容            [item.filename]: {                dependencies: item.dependencies,                code: item.code            }        }),        {}        )        this.generate(dependencyGraph);    }    build(filename) {        const { getAst, getDependecies, getCode } = Parser        const ast = getAst(this.entry);        const dependencies = getDependecies(this.entry);        const code = getCode(ast);        return {            filename,            dependencies,            code        }    }    // 重写 require 函数， 输出bundle    generate() {        const filepath = path.join(this.output.path, this.output.filename);        const bundle = `(function(graph){            function require(moulde) {                function localRequire(relativePath) {                    return require(graph[module].dependencies[relativePath])                }                var exports = [];                (function(require, exports, code){                    eval(code)                })(localRequire, exports, graph[module].code)                return exports            }            require('${this.entry}')        })(${JSON.stringify(code)})`        // 把文件写入文件系统        fs.writeFileSync(filepath, bundle, 'utf-8')    }}class Event {    constructor() {        this.handlers = {}    }    on = (eventName, cb) => {        const eventCallbackStack = this._getHandler(eventName).callbackStack;        callbackStack.push(cb)    }    emit = (eventName, ...args) => {        if(this.handlers[eventName]) {            this.handlers[eventName].eventCallbackStack.forEach(() => {                cb.call(cb, ...args);            })        }        if(this.handlers[eventName].isOnce) {            this.off(eventName)        }    }    off = (eventName) => {        if(this.handlers[eventName]) {            delete this.handlers[eventName];        }    }    once = () => {        const eventCallbackStack = this._getHandler(eventName, true).callbackStack;        callbackStack.push(cb)    }    _getHandler = (eventName, isOnce) => {        if(!this.handlers[eventName]) {            this.handlers[eventName] = {                isOnce,                callbackStack: []            }        }        return this.handlers[eventName]    }}const threeSum = function(nums) {    let result = [];    const len = nums.length;    if(nums == null || len < 2) return result;    // 排序    for(let i = 0; i < len; i++) {        // 如果当前数字大于0， 则三数之和一定大于0， 所以结束循环        if(nums[i] > 0) break;        if(i > 0 && nums[i] == nums[i-1]) continue; // 去重        let left = i + 1;        let right = len - 1;        while(left < right) {            const sum = nums[i] + nums[left] + nums[right];            if (sum == 0) {                result.push([nums[i], nums[left], nums[right]]);                while(left < right && nums[left] == nums[left + 1]) left++;                while(left < right && nums[right] == nums[right + 1]) right--;                left++;                right++            } else if(sum > 0) {                right--;            } else {                left++            }        }            }    return result;}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>react/index</title>
    <link href="/2021/03/17/react/index/"/>
    <url>/2021/03/17/react/index/</url>
    
    <content type="html"><![CDATA[<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p><strong>instanceof</strong> 判断左边原型是否存在右边的原型链中<br>实现思路： 逐层网上查找原型，如果最终原型为null，证明不在原型链中，否认存在</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span> (<span class="hljs-params">left, right</span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> left !== <span class="hljs-string">'object'</span> || left === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototype(left);    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;        <span class="hljs-keyword">if</span>(proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span>(proto === right.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        proto = <span class="hljs-built_in">Object</span>.getPrototype(proto);    &#125;&#125;</code></pre><h4 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h4><p>创建一个继承 obj 原型属性的纯净对象</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> myCreate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;    F.prototype = obj;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();&#125;</code></pre><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>new 被调用做了三件事</p><ul><li>让实例对象可以访问到私有属性</li><li>让实例对象可以访问构造函数原型所在的原型链的属性</li><li>考虑构造函数有返回值的<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 1.获得构造函数，同时删除arguments 中第一个参数；</span>    <span class="hljs-keyword">let</span> ctor = [].shift.call(<span class="hljs-built_in">arguments</span>);    <span class="hljs-comment">// 2.创建一个空的对象饼链接到原型， obj可以访问构造函数原型中的属性</span>    <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(ctor.prototype);    <span class="hljs-comment">// 3.绑定 this 实现继承，object 可以访问到构造函数中的属性</span>    <span class="hljs-keyword">let</span> result = ctor.apply(obj, <span class="hljs-built_in">arguments</span>);    <span class="hljs-comment">// 4.优先返回构造函数返回的对象</span>    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ? result : obj;&#125;</code></pre><h4 id="call-amp-apply"><a href="#call-amp-apply" class="headerlink" title="call&amp;apply"></a>call&amp;apply</h4>实现思路： 利用谁调用函数，函数的this 就指向谁这一特点实现<pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">'caller must be a function'</span>;    <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] || <span class="hljs-built_in">window</span>;    self._fn = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">let</span> args = [...arguments].flat().slice(<span class="hljs-number">1</span>) <span class="hljs-comment">// 展开后取参数列表</span>    <span class="hljs-keyword">let</span> res = self._fn(...args);    <span class="hljs-keyword">delete</span> self._fn;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4>bind 用于改变 this指向 并返回一个函数<pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">'caller must be a function'</span>;    <span class="hljs-keyword">let</span> self = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> fnArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);        self.apply(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> self ? <span class="hljs-keyword">this</span>: context, args.concat(fnArgs))            &#125;    fn.prototype = <span class="hljs-built_in">Object</span>.create(self.prototype) <span class="hljs-comment">// 维护原型</span>    <span class="hljs-keyword">return</span> fn&#125;</code></pre><h4 id="curry"><a href="#curry" class="headerlink" title="curry"></a>curry</h4><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn, args=[]</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> newArgs = args.concat(<span class="hljs-built_in">Array</span>.prototype.slice(<span class="hljs-built_in">arguments</span>));        <span class="hljs-keyword">if</span> (newArgs.length &lt; fn.length) &#123;            <span class="hljs-keyword">return</span> curry.call(<span class="hljs-keyword">this</span>, fn, newArgs)        &#125; eles &#123;            <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, newArgs)        &#125;    &#125;&#125;</code></pre><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><h5 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h5><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = arr.length; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; i++) &#123;            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;                [arr[j], arr[j + <span class="hljs-number">1</span>]] = [arr[j + <span class="hljs-number">1</span>], arr[j]]            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> nums&#125;</code></pre><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">if</span>(arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;    <span class="hljs-keyword">let</span> left = [], right = [], mid = arr.splice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i ++) &#123;        <span class="hljs-keyword">if</span> (arr[i] &lt; mid) &#123;            left.push(arr[i])        &#125; <span class="hljs-keyword">else</span> &#123;            right.push(arr[i])        &#125;    &#125;    <span class="hljs-keyword">return</span> quickSort(left).concat(mid, quickSort(right))&#125;</code></pre><h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shadowCopy</span>(<span class="hljs-params">source</span>) </span>&#123;    <span class="hljs-keyword">var</span> target = &#123;&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> source) &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;            target[key] = source[key]        &#125;    &#125;&#125;<span class="hljs-keyword">return</span> target;</code></pre><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5>JSON.parse(JSON.stringify(a)) 这种方法无法解决循环引用 无法拷贝特殊对象<br>解决方案： 使用哈希表：检测当前对象，取该值<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">source， hash = new WeakMap(</span>)) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span> obj !== <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">if</span>(!isObject(source)) <span class="hljs-keyword">return</span> source;    <span class="hljs-keyword">if</span>(hash.has(soucre)) <span class="hljs-keyword">return</span> hash.get(source);    <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;    hash.set(source, target);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> source) &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">'object'</span>) &#123;            deepClone(source[key])        &#125; <span class="hljs-keyword">else</span> &#123;            target[key] = source[key]        &#125;    &#125;    <span class="hljs-keyword">return</span> target;&#125;</code></pre><h4 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖/节流"></a>防抖/节流</h4><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;        <span class="hljs-keyword">if</span>(timer) clearTimeout(timer)        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            fn.apply(<span class="hljs-keyword">this</span>, args)        &#125;, delay)    &#125;&#125;</code></pre><h5 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h5><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;        <span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">return</span>;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            fn.apply(<span class="hljs-keyword">this</span>, args)            flag = <span class="hljs-literal">true</span>;        &#125;, delay)    &#125;&#125;</code></pre><h4 id="加强版节流"><a href="#加强版节流" class="headerlink" title="加强版节流"></a>加强版节流</h4><pre><code class="hljs js"><span class="hljs-keyword">const</span> throttle = <span class="hljs-function">(<span class="hljs-params">fn, delay</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>, last = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-keyword">if</span>(now - last = delay &amp;&amp; timer) &#123;            clearTimer(timer);            timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                fn.apply(<span class="hljs-keyword">this</span>, args)            &#125;, delay)        &#125; <span class="hljs-keyword">else</span> &#123;            last = now;            fn.appy(<span class="hljs-keyword">this</span>, args)        &#125;    &#125;&#125;</code></pre><h4 id="Promise-系列"><a href="#Promise-系列" class="headerlink" title="Promise 系列"></a>Promise 系列</h4>链式调用<br>错误捕获<h5 id="promise-race"><a href="#promise-race" class="headerlink" title="promise.race"></a>promise.race</h5><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.race = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(promises.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        promises.forEach(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;            <span class="hljs-built_in">Promise</span>.resolve(promise).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;                resolve(data)                <span class="hljs-keyword">return</span>;            &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                reject(err)                <span class="hljs-keyword">return</span>;            &#125;)        &#125;)     &#125;)&#125;</code></pre><h5 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all"></a>promise.all</h5><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> result = [],            index = <span class="hljs-number">0</span>            len = promises.length;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proccessData</span>(<span class="hljs-params">data, idx</span>) </span>&#123;            result[idx] = data;            index++;        &#125;        promises.forEach(<span class="hljs-function">(<span class="hljs-params">item, idx</span>) =&gt;</span> &#123;            <span class="hljs-built_in">Promise</span>.resolve(item).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;                processData(data, idx);                <span class="hljs-keyword">if</span>(index ==len) &#123;                    resolve(result);                &#125;            &#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;                reject(err)            &#125;)        &#125;)    &#125;)&#125;</code></pre></li></ul><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">this</span>.observers = [] <span class="hljs-comment">//观察者队列</span>    &#125;        add(observer) &#123;        <span class="hljs-keyword">this</span>.observers.push(observer);        <span class="hljs-keyword">this</span>.observers = [...new <span class="hljs-built_in">Set</span>(<span class="hljs-keyword">this</span>.oberservers)];    &#125;    notify(..agrs) &#123;        <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> observer.update(...agrs))    &#125;   remove(observer) &#123;       <span class="hljs-keyword">let</span> observers = <span class="hljs-keyword">this</span>.observers;       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i= <span class="hljs-number">0</span>; i &lt; observers.lenght; i++) &#123;           <span class="hljs-keyword">if</span>(observer === observer[i]) &#123;               observers.splice(i, <span class="hljs-number">1</span>)           &#125;       &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;    update(...ars) &#123;        <span class="hljs-built_in">console</span>.log(...args)    &#125;&#125;</code></pre><h5 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h5><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">this</span>.handles = &#123;&#125;    &#125;    on = (eventName, cb) &#123;        <span class="hljs-keyword">const</span> eventCallback = <span class="hljs-keyword">this</span>._getHandler(eventName).callbackStack;        eventCallback.push(cb);    &#125;    emit = <span class="hljs-function">(<span class="hljs-params">eventName, ...args</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.handlers[eventName]) &#123;            <span class="hljs-keyword">this</span>.handlers[eventName].callbackStack.for(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                cb.call(cb, ...args);            &#125;)        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.handlers[eventName].isOnce) &#123;            <span class="hljs-keyword">this</span>.off(eventName)        &#125;    &#125;    off = <span class="hljs-function">(<span class="hljs-params">eventName</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.handlers[eventName]) &#123;            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.handlers[eventName];        &#125;    &#125;    once = <span class="hljs-function">(<span class="hljs-params">eventName</span>) =&gt;</span> &#123;        <span class="hljs-keyword">const</span> eventCallbackStack = <span class="hljs-keyword">this</span>._getHandler(eventName, <span class="hljs-literal">true</span>).callbackStack;        callbackStack.push(cb)    &#125;    _getHandler = <span class="hljs-function">(<span class="hljs-params">eventName</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.handlers[eventName]) &#123;            <span class="hljs-keyword">this</span>.hanlers[eventName] = &#123;                isOnce,                callbackStack: []            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.handlers[eventName]    &#125;   &#125;</code></pre><h4 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h4><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStore</span>(<span class="hljs-params">reducer, enhancer</span>) </span>&#123;    <span class="hljs-comment">// 先处理 enhancer</span>    <span class="hljs-comment">// 如果 enhancer 存在并且是函数， 我们将 createStore 作为参数传给它</span>    <span class="hljs-comment">// 在拿这个 新的createStore执行，应该得到一个Store，返回Store</span>    <span class="hljs-keyword">if</span>(enhancer &amp;&amp; <span class="hljs-keyword">typeof</span> enhancer === <span class="hljs-string">'function'</span>) &#123;        <span class="hljs-keyword">const</span> newCreateStore = enhancer(createStore);        <span class="hljs-keyword">const</span> newStore = newCreateStore(reducer)        <span class="hljs-keyword">return</span> newStore;    &#125;    <span class="hljs-keyword">let</span> state, <span class="hljs-comment">// state记录所有状态</span>        listeners = [] <span class="hljs-comment">// 保存所有的注册回调</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subscribe</span>(<span class="hljs-params">callback</span>) </span>&#123;        listeners.push(callback)    &#125;    <span class="hljs-comment">// 先执行reducer 修改并返回新的state，然后将所有的回调拿出来依次执行</span>     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params">action</span>) </span>&#123;         state = reducer(state, action) <span class="hljs-comment">//这一步别忘</span>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) &#123;             <span class="hljs-keyword">const</span> listener = listeners[i]             listener()         &#125;     &#125;     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getState</span>(<span class="hljs-params"></span>) </span>&#123;         <span class="hljs-keyword">return</span> state;     &#125;     <span class="hljs-comment">// store 包装一下前面的方法直接返回</span>     <span class="hljs-keyword">const</span> store = &#123;         subscribe,         dispatch,         getState     &#125;     <span class="hljs-keyword">return</span> store;&#125;</code></pre><h4 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h4><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(key, value) &#123;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.value = value;        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">this</span>.prev = <span class="hljs-literal">null</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(capacity) &#123;        <span class="hljs-keyword">this</span>.capacity = capacity;        <span class="hljs-keyword">this</span>.hash = &#123;&#125;        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>        <span class="hljs-keyword">this</span>.dummyHead = <span class="hljs-keyword">new</span> ListNode()        <span class="hljs-keyword">this</span>.dummyTail = <span class="hljs-keyword">new</span> ListNode()        <span class="hljs-keyword">this</span>.dummyHead.next = <span class="hljs-keyword">this</span>.dummyTail;        <span class="hljs-keyword">this</span>.dummyTail.prev = <span class="hljs-keyword">this</span>.dummyHead;    &#125;    <span class="hljs-keyword">get</span>() &#123;        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.hash[key]        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        <span class="hljs-keyword">this</span>.moveToHead(node);        <span class="hljs-keyword">return</span> node.value;    &#125;    put(key, value) &#123;        <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.hash[key];        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.count == <span class="hljs-keyword">this</span>.capacity) &#123;                <span class="hljs-keyword">this</span>.removeLRUItem()            &#125;            <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> ListNode(key, value);            <span class="hljs-keyword">this</span>.hash[key] = newNode;            <span class="hljs-keyword">this</span>.addTohead(newNode);            <span class="hljs-keyword">this</span>.count++;        &#125; <span class="hljs-keyword">else</span> &#123;            node.value = value;            <span class="hljs-keyword">this</span>.moveTohead(node)        &#125;    &#125;        moveToHead(node) &#123;        <span class="hljs-keyword">this</span>.removeFromList(node);        <span class="hljs-keyword">this</span>.addToHead(node)    &#125;    removeFromToList(node) &#123;        <span class="hljs-keyword">let</span> temp1 = node.prev;        <span class="hljs-keyword">let</span> temp2 = node.next        temp1.next = tem2;        temp2.prev = temp1    &#125;    addToHead(node) &#123;        node.prev = <span class="hljs-keyword">this</span>.dummyHead;        node.next = <span class="hljs-keyword">this</span>.dummyHead.next;        <span class="hljs-keyword">this</span>.dummyHead.next.prev = node;        <span class="hljs-keyword">this</span>.dummyHead.next = node;    &#125;    removeLRUItem() &#123;        <span class="hljs-keyword">let</span> tail = <span class="hljs-keyword">this</span>.popTail();        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.hash[tail.key]        <span class="hljs-keyword">return</span> tail    &#125;    popTail() &#123;        <span class="hljs-keyword">let</span> tail = <span class="hljs-keyword">this</span>.dummyTail.prev;        <span class="hljs-keyword">this</span>.removeFromList(tail);        <span class="hljs-keyword">return</span> tail    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/Array/index</title>
    <link href="/2021/03/17/algorithm/Array/index/"/>
    <url>/2021/03/17/algorithm/Array/index/</url>
    
    <content type="html"><![CDATA[/** 数组的扁平化* 已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];* 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组* */Array.prototype.flat = function (arr, result) {  result  arr.forEach((item) => {    Array.isArray(item) ? arguments.callee(item) : item.push(newArr)  })  return newArr}var levelOrder = function(root) {  const ret = [];  if (!root) {      return ret;  }  const q = [];  q.push(root);  while (q.length !== 0) {      const currentLevelSize = q.length;      ret.push([]);      for (let i = 1; i <= currentLevelSize; ++i) {          const node = q.shift();          ret[ret.length - 1].push(node.val);          if (node.left) q.push(node.left);          if (node.right) q.push(node.right);      }  }        return ret;};]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/Function/compose</title>
    <link href="/2021/03/17/algorithm/Function/compose/"/>
    <url>/2021/03/17/algorithm/Function/compose/</url>
    
    <content type="html"><![CDATA[/** * 函数的组合 */let toUpperCase = function (str) {    return str.toUpperCase(str);}let hello = function(name) {    return `hi, {name}!`;}let sayHello = function() {    return hello(toUpperCase('Tom'));}/** * 我们可以看到 hello 函数使用了 toUpperCase的返回值 类似于 * sayHello = f(g(x)), 这时我们可以写一个compose 函数 将这个函数做为参数*/function _compose(f, g) {    return function (x) {        return f(g(x));    }}/** * 如果 compose(f, g, h, i)? * 难道要写成 compose(f, compose(g, compose(h, i))? */function compose() {    let length = arguments.length;    let args = arguments;    return function () {        let start = length -1;        let result = args.apply(this, arguments);        while (start--) args[start].apply(this, result)        return result;    }}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/Function/curry</title>
    <link href="/2021/03/17/algorithm/Function/curry/"/>
    <url>/2021/03/17/algorithm/Function/curry/</url>
    
    <content type="html"><![CDATA[/** * @name curry * @version 1.0 * @description 函数的柯里化  * @param fn * @param num * @example curry(add, 1, 2)*/function _curry(fn) {    const args = [].slice.apply(arguments, 1);    return function () {        return fn.apply(this, args.concat(...arguments))    }}/** * @name curry * @version 1.1 * @param fn * @description currying is a technique of translating an evaluation of a function  * that takes multiple arguments (or tuple arguments) into evaluating a sequence  * functions, each with a single function; * @param length fn的参数个数 * @example curry(add(1, 2)) */ function curry(fn, length) {    // 判断要curry的函数的参数个数      length = length || fn.length;    let slice = Array.prototype.slice;    return function () {        if(arguments.length < length) {            const args = [fn].concat(slice.apply(this, arguments))            return curry(_curry.apply(this, args), length - arguments.length);        } else {            return fn.apply(this, arguments)        }            } }]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/Function/index</title>
    <link href="/2021/03/17/algorithm/Function/index/"/>
    <url>/2021/03/17/algorithm/Function/index/</url>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="如何定义函数"><a href="#如何定义函数" class="headerlink" title="如何定义函数"></a>如何定义函数</h3><ul><li><p>普通函数： 用<em>function</em>关键字定义的函数</p><pre>  function foo () {  }</pre></li><li><p>箭头函数：用 =&gt; 运算符定义的函数</p><pre>  const foo = () => {      // code  }</pre></li><li><p>方法： 在class中定义的函数</p><pre>  class C {      foo () {          // code      }  }</pre></li><li><p>生成器函数： 用function* 定义的函数</p><pre>  function* foo() {      // code  }</pre></li><li><p>类：用class定义的类，实际上也是函数</p> <pre>  class Foo {      constructor() {      }      // code  }</pre></li><li><p>其他： 异步函数： 普通函数、箭头函数和生成器函数前 增加async关键字</p>  <pre>      async function foo() {      }      const foo = async () =>  {      }      async function* foo() {              // code      }  </pre></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Apollo-Server</title>
    <link href="/2020/07/06/Apollo-Server/index/"/>
    <url>/2020/07/06/Apollo-Server/index/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Apollo-Server-是什么"><a href="#Apollo-Server-是什么" class="headerlink" title="Apollo Server 是什么"></a>Apollo Server 是什么</h4><p> <a href="http://www.baidu.com" target="_blank" rel="noopener">Apollo Server</a> 是一种符合规范的开源 GraphQL服务器，能与任何GraphQL客户端（包括Apollo Client）兼容。并且可以使用任何来源数据去构建生产预发环境、生成 GraphQL API 文档的最佳方法。</p><p> 您可以将<strong>Apollo Server</strong>用作：</p><ul><li><p>独立的GraphQL服务器，包括在serverless环境中</p></li><li><p>现有应用的Node.js中间件的扩展（例如Express或Fastify）的附件</p></li><li><p>Federated data graph的网关</p><p><strong>Apollo Server</strong> 提供：</p></li><li><p>简单易用的设置，因此您的客户端开发人员可以快速开始获取数据</p></li><li><p>渐进式采用，使您可以根据需要添加功能</p></li><li><p>可以兼容任何数据源、构建工具、GraphQL客户端</p></li><li><p>生产就绪，使您能够更快地发布功能</p></li></ul><h3 id="开始使用-Apollo-Server"><a href="#开始使用-Apollo-Server" class="headerlink" title="开始使用 Apollo Server"></a>开始使用 Apollo Server</h3><blockquote><p>本教程主要引导你安装和配置Apollo Server。如果您刚刚开始使用GraphQL 或者 Apollo平台，我们推荐您先完成<a href="https://www.apollographql.com/docs/tutorial/introduction" target="_blank" rel="noopener">full-stack-tutorial</a>。</p></blockquote><p>本教程可以帮助您：</p><ul><li>对GraphQL原理有基本了解</li><li>定义一个代表数据集结构的GraphQL <strong>schema</strong></li><li>运行Apollo Server实例，使您可以依照你的schema执行查询</li></ul><p>本教程假定您熟悉命令行和JavaScript，并且已安装了最新版本的Node.js（8+）。</p><h4 id="第一步：创建一个新的项目"><a href="#第一步：创建一个新的项目" class="headerlink" title="第一步：创建一个新的项目"></a>第一步：创建一个新的项目</h4><p>1.在您首选的开发目录中，为新项目创建目录并 <code>cd</code> 进入该目录：</p><pre><code class="hljs plain">mkdir graphql-server-examplecd graphql-server-example</code></pre><p>2.使用<code>npm</code>（或您喜欢的另一个包管理器，例如Yarn）初始化一个新的Node.js项目：</p><pre><code class="hljs plain">npm init --yes</code></pre><p>您的项目目录现在包含一个<code>package.json</code>文件。</p><h4 id="第二步：安装依赖项"><a href="#第二步：安装依赖项" class="headerlink" title="第二步：安装依赖项"></a>第二步：安装依赖项</h4><p>运行Apollo Server的应用程序需要两个顶级依赖项：</p><ul><li><a href="https://www.npmjs.com/package/apollo-server" target="_blank" rel="noopener">apollo-server</a> 是Apollo Server本身的核心库，可帮助您定义数据的形状以及如何获取数据。</li><li><a href="https://www.npmjs.com/package/graphql" target="_blank" rel="noopener">graphql</a> 是用于构建GraphQL Schema并对其执行查询的库。</li></ul><p>运行以下命令以安装这两个依赖项并将它们保存在项目的<code>node_modules</code>目录中：</p><pre><code class="hljs plain">npm install apollo-server graphql</code></pre><p>还要<code>index.js</code>在项目的根目录中创建一个空文件：</p><pre><code class="hljs plain">touch index.js</code></pre><p>为简单起见，<code>index.js</code>将包含此示例应用程序的所有代码。</p><h4 id="第三步：定义您的GraphQL-Schema"><a href="#第三步：定义您的GraphQL-Schema" class="headerlink" title="第三步：定义您的GraphQL Schema"></a>第三步：定义您的GraphQL Schema</h4><p>每个GraphQL服务器（包括Apollo服务器）都使用一种<strong>Schema</strong>来定义客户端可以查询的数据结构。在此示例中，我们将创建一个服务器，用于按书名和作者查询书籍集合。</p><p><code>index.js</code>在您喜欢的编辑器中打开并将以下内容粘贴到其中：</p><pre><code class="hljs plain">const &#123; ApolloServer, gql &#125; &#x3D; require(&#39;apollo-server&#39;);&#x2F;&#x2F; A schema is a collection of type definitions (hence &quot;typeDefs&quot;)&#x2F;&#x2F; that together define the &quot;shape&quot; of queries that are executed against&#x2F;&#x2F; your data.const typeDefs &#x3D; gql&#96;  # Comments in GraphQL strings (such as this one) start with the hash (#) symbol.  # This &quot;Book&quot; type defines the queryable fields for every book in our data source.  type Book &#123;    title: String    author: String  &#125;  # The &quot;Query&quot; type is special: it lists all of the available queries that  # clients can execute, along with the return type for each. In this  # case, the &quot;books&quot; query returns an array of zero or more Books (defined above).  type Query &#123;    books: [Book]  &#125;&#96;;</code></pre><p>此代码段定义了一个简单有效的GraphQL Schema。客户将能够执行名为的查询books，并且我们的服务器将返回零个或多个Books 的数组。</p><h4 id="第四步：定义您的数据集"><a href="#第四步：定义您的数据集" class="headerlink" title="第四步：定义您的数据集"></a>第四步：定义您的数据集</h4><p>现在我们已经定义了数据的结构，我们可以定义数据本身了。Apollo服务器可以从您连接到的任何源（包括数据库，REST API，静态对象存储服务，甚至另一个GraphQL服务器）中获取数据。出于本教程的目的，我们将对一些示例数据进行硬编码。</p><p>将以下内容添加到的底部<code>index.js</code>：</p><pre><code class="hljs plain">const books &#x3D; [  &#123;    title: &#39;Harry Potter and the Chamber of Secrets&#39;,    author: &#39;J.K. Rowling&#39;,  &#125;,  &#123;    title: &#39;Jurassic Park&#39;,    author: &#39;Michael Crichton&#39;,  &#125;,];</code></pre><p>此代码段定义了客户端可以查询的简单数据集。注意，数组中的两个对象均与Book我们在架构中定义的类型的结构匹配。</p><h4 id="第五步：定义解析器"><a href="#第五步：定义解析器" class="headerlink" title="第五步：定义解析器"></a>第五步：定义解析器</h4><p>我们已经定义了数据集，但是Apollo Server不知道在执行查询时应该如何使用该数据集。为了解决这个问题，我们创建了一个 resolver。</p><p>让解析器告诉Apollo Server 如何获取与特定类型关联的数据。因为我们的Book数组是硬编码的，所以相应的解析器很简单。</p><p>将以下内容添加到的底部<code>index.js</code>：</p><pre><code class="hljs plain">&#x2F;&#x2F; Resolvers define the technique for fetching the types defined in the&#x2F;&#x2F; schema. This resolver retrieves books from the &quot;books&quot; array above.const resolvers &#x3D; &#123;  Query: &#123;    books: () &#x3D;&gt; books,  &#125;,&#125;;</code></pre><h4 id="第六步：创建ApolloServer实例"><a href="#第六步：创建ApolloServer实例" class="headerlink" title="第六步：创建ApolloServer实例"></a>第六步：创建ApolloServer实例</h4><p>我们已经定义了架构，数据集和解析器。现在，我们只需要在初始化时向Apollo Server提供此信息即可。</p><p>将以下内容添加到的底部index.js：</p><pre><code class="hljs plain">&#x2F;&#x2F; The ApolloServer constructor requires two parameters: your schema&#x2F;&#x2F; definition and your set of resolvers.const server &#x3D; new ApolloServer(&#123; typeDefs, resolvers &#125;);&#x2F;&#x2F; The &#96;listen&#96; method launches a web server.server.listen().then((&#123; url &#125;) &#x3D;&gt; &#123;  console.log(&#96;🚀  Server ready at $&#123;url&#125;&#96;);&#125;);</code></pre><h4 id="第七步：启动服务器"><a href="#第七步：启动服务器" class="headerlink" title="第七步：启动服务器"></a>第七步：启动服务器</h4><p>我们已经准备好启动服务器！从项目的根目录运行以下命令：</p><pre><code class="hljs plain">node index.js</code></pre><p>您应该看到以下输出：</p><pre>🚀 Server ready at http://localhost:4000/</pre><h4 id="第八步：执行第一个查询"><a href="#第八步：执行第一个查询" class="headerlink" title="第八步：执行第一个查询"></a>第八步：执行第一个查询</h4><p>现在，我们可以在服务器上执行GraphQL查询。要执行查询时，我们将使用一个名为GraphQL Playground的工具。</p><div class="note note-info">            <p>注意：如果将服务器部署到NODE_ENV设置为的环境，则production默认情况下将禁用GraphQL Playground和自省功能。要启用它们，您需要显式设置，playground: true并 introspection: true在的Constructor 选项ApolloServer内。</p>          </div><p>在服务器仍在运行的情况下，<a href="http://localhost:4000在浏览器中访问以打开GraphQL">http://localhost:4000在浏览器中访问以打开GraphQL</a> Playground。（在开发中运行GraphQL Playground时，Apollo Server会自动托管它。</p><p>GraphQL Playground UI包括</p><ul><li>用于编写查询的文本区域（左侧）</li><li>用于执行查询的“播放”按钮（中间的三角形按钮）</li><li>用于查看查询结果的文本区域（右侧）</li><li>查看架构检查和生成的文档的视图（通过右侧的选项卡）</li></ul><p>我们的服务器支持一个名为的查询<code>books</code>。让我们执行它！</p><p>这是用于执行查询的GraphQL 查询字符串<code>books</code>。</p><pre>{  books {    title    author  }}</pre><p>将此字符串粘贴到左侧文本区域，然后单击“播放”按钮。结果（来自我们的硬编码数据集）显示在右侧：</p><p>GraphQL的最重要概念之一是我们可以选择仅查询 所需的字段。<code>author</code>从查询字符串中删除并再次执行。响应更新为仅包括<code>title</code>每本书的字段！</p><h3 id="定义一个Schema"><a href="#定义一个Schema" class="headerlink" title="定义一个Schema"></a>定义一个Schema</h3><h4 id="schema基础"><a href="#schema基础" class="headerlink" title="schema基础"></a>schema基础</h4><p>GraphQL服务器使用<strong>Schema</strong>描述数据图的形状。Schema用来源于后端的数据字段来定义不同层级类型层次，schema还精确指定了能针对您的数据图、可用于客户端执行的query和mutation。<br>本文旨在介绍schema的基本构成以及如何为您的GraphQL服务器创建一个Schema。</p><h5 id="schema定义语言"><a href="#schema定义语言" class="headerlink" title="schema定义语言"></a>schema定义语言</h5><p>GraphQL规范包含一种人类可读的架构定义语言（或SDL），可用于定义Schema并将其存储为字符串</p><p>我们来定义两个对象类型：<code>Author</code> 和 <code>Book</code></p><pre>type Book {  title: String  author: Author}type Author {  name: String  books: [Book]}</pre><p>Schema 定义了类型的集合和类型的关系。在上面的例子中，每一个<code>Book</code>有一个<code>author</code>，每一个<code>Author</code>有<code>books</code>的列表。通过在整合的Schema中定义这些类型的关系，我们可以确保每一个客户端开发者可以准确查看可用数据，<br>并且通过单个优化查询请求该数据的特定子集</p><p>注意Schema并不关注数据的来源或者如何存储。它完全与实现无关。</p><h5 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h5><ul><li>标量类型</li><li>对象类型</li><li>Query 类型</li><li>Mutation 类型</li><li>输入类型<br>下面分别详细介绍这些内容。</li></ul><h6 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h6><p>标量类型类似于编程语言中的基本类型。他们总是解析具体的数据。</p><p>GraphQL的默认标量类型为：</p><ul><li><code>Int</code>：有符号的32位整数</li><li><code>Float</code>：带符号的双精度浮点值</li><li><code>String</code>：UTF-8字符序列</li><li><code>Boolean</code>：true或false</li><li><code>ID（序列化为String）</code>：唯一标识符，通常用于重新获取对象或用作缓存的键。尽管将其序列化为String，但<code>ID</code>并不旨在使其易于理解。</li></ul><p>这些原始类型涵盖了大多数用例。对于更特定的用例，您可以创建自定义标量类型。</p><h6 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h6><p>在GraphQL模式中定义的大多数类型都是对象类型。对象类型包含字段的集合，每个字段可以是标量类型或其他对象类型。</p><p>两种对象类型可以彼此包含为字段，就像前面的示例Schema中那样：</p><pre>type Book {  title: String  author: Author}type Author {  name: String  books: [Book]}</pre><h6 id="Query-类型"><a href="#Query-类型" class="headerlink" title="Query 类型"></a>Query 类型</h6><p>Query类型定义根据您的数据图执行查询的入口点。它类似于对象类型，但其名称始终为Query。</p><p>Query类型的每个字段定义不同入口点的名称和返回类型。Query我们的Schema类型可能类似于以下内容：</p><pre>type Query {  books: [Book]  authors: [Author]}</pre><p>这个查询类型定义了两个字段：<code>books</code> 和 <code>authors</code>。每个字段都返回一个列表<br>基于RestFul API，books 和 authors 很可能从不同的端点返回（eg： <code>/api/books</code> 和 <code>/api/authors</code>。而GraphQL的灵活性能保证通过一个请求返回这两个数据。</p><p><strong>构造一个query</strong><br>当你开始根据你的数据图来创建查询时，这些查询必须与你在Schema中定义好的结构相匹配。</p><p>基于我们例子中Schema，客户端执行下面的查询操作，将会返回所有的books和author 的列表</p><pre>query GetBooksAndAuthors {  books {    title  }  authors {    name  }}</pre><p>服务端会根据查询结构，将查询到的结果做如下返回</p><pre>{  "data": {    "books": [      {        "title": "Jurassic Park"      },      ...    ],    "authors": [      {        "name": "Michael Crichton"      },      ...    ]  }}</pre><p>尽管在某些情况下获取这两个单独的列表可能很有用，但是客户可能更喜欢获取一个图书列表，其中每本书的作者都包含在结果中。<br>因为我们的Schema的Book类型具有type的author字段Author，所以客户端可以改为这样构造其查询：</p><pre>query GetBooks {  books {    title    author {      name    }  }}</pre><p>再一次，我们的服务器将响应与查询结构匹配的结果：</p><pre>{  "data": {    "books": [      {        "title": "Jurassic Park",        "author": {          "name": "Michael Crichton"        }      },      ...    ]  }}</pre><h6 id="Mutation-类型"><a href="#Mutation-类型" class="headerlink" title="Mutation 类型"></a>Mutation 类型</h6><p>Mutation类型在结构和目的与Query类型类似。Query类型定义了读操作的入口点，而Mutation类型定义了写操作的入口点。</p><p>Mutation类型的每个字段定义不同入口点的标志和返回类型。Mutation我们的示例Schema的类型可能类似于以下内容：</p><pre>type Mutation {  addBook(title: String, author: String): Book}</pre><p>这个mutation类型定义了一个可用的mutation，<code>addBook</code>。这个mutation接收两个参数（title和author）并且返回一个新的<code>Book</code>对象。正如你所期望的，这个<code>Book</code>对象遵循我们在schema中定义的结构。</p><p><strong>构造一个mutation</strong><br>和query一样，mutations也应与我们的schema 定义的类型相匹配。下面的mutation 创建了一个新的<code>Book</code>而且请求已创建的对象的特定字段作为返回值。</p><pre>mutation CreateBook {  addBook(title: "Fox in Socks", author: "Dr. Seuss") {    title    author {      name    }  }}</pre><p>服务端将根据我们设计的mutation结构返回结果</p><pre>{  "data": {    "addBook": {      "title": "Fox in Socks",      "author": {        "name": "Dr. Seuss"      }    }  }}</pre><p>一个客户端请求可能包含多个需要执行的mutation。为了避免出现竞态，mutations的执行是线性的（根据列出的顺序）</p><p>学习更多关于mutations的设计</p><h6 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h6><p>输入类型是特殊的对象类型，它允许你传递一个对象作为参数进行query和mutation操作（与仅支持传标量类型相对）。输入类型可以帮助保持操作标识的整洁，就像在JavaScript函数中接受单个<code>options</code>对象比重复添加参数更干净一样。</p><p>看一下这个提交创建blog的mutation操作：</p><pre>type Mutation {  createPost(title: String, body: String, mediaUrls: [String]): Post}</pre><p>与接收三个参数相对，下面这个mutation只接受一个输入类型（包含这三个参数）。如果我们在将来决定增加一个参数会显得格外的方便，例如 <code>author</code></p><p>定义输入类型和对象类型很相似， 唯一不同就是我们需要使用 <code>input</code>关键字</p><pre>type Mutation {  createPost(post: PostAndMediaInput): Post}input PostAndMediaInput {  title: String  body: String  mediaUrls: [String]}</pre><p>输入类型不仅促进了PostAndMediaInput类型在我们Schema中的传递，而且提供了给字段增加注释空间，该描述可以自动的暴露给GraphQL可用工具。</p><pre>input PostAndMediaInput {  "A main title for the post"  title: String  "The text body of the post."  body: String  "A list of URLs to render in the post."  mediaUrls: [String]}</pre><p>当多个操作需要完全相同的数据集合时，输入类型有时会很有用，但是您应该谨慎地复用它们。操作最终可能会在其所需的参数之间产生分歧。</p><p><strong>不要对query和mutation使用相同</strong>的输入类型。在许多情况下，mutation所需的参数对于相应的query是可选的。</p><h5 id="Schema的演变"><a href="#Schema的演变" class="headerlink" title="Schema的演变"></a>Schema的演变</h5><p>随着你的组织成长与演变，你的数据图也会相应的成长。新的产品和特性会引入新的Schema类型和字段。为了追踪这段时间的变化，你应该用版本控制去维护你的定义的Schema。</p><p>大多数的Schema的增加是安全且向后兼容的。但是，发生的变化产生的删除和修改行为对于一个或更多已存在的应用可能是破坏性的改变。下面的schema改变会具有潜在的破坏性：</p><ul><li>删除一个类型或字段</li><li>重命名一个类型或字段</li><li>增加一个可为空字段</li><li>删除一个字段参数</li></ul><p>诸如Apollo Studio[<a href="https://studio.apollographql.com]之类的图形管理工具可帮助您了解潜在的Schema更改是否会影响您的正在使用客户端。Studio还通过操作安全列表提供字段级性能指标，Schema历史记录跟踪和高级安全性。">https://studio.apollographql.com]之类的图形管理工具可帮助您了解潜在的Schema更改是否会影响您的正在使用客户端。Studio还通过操作安全列表提供字段级性能指标，Schema历史记录跟踪和高级安全性。</a></p><h5 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h5><p>GraphQL的Schema定义语言（SDL）支持启用markdown的文档字符串。这些可帮助数据图的使用者发现字段并学习如何使用它们。</p><p>以下代码段显示了如何同时使用单行字符串文字和多行块：</p><pre>"Description for the type"type MyObjectType {  """  Description for field  Supports **multi-line** description for your [API](http://example.com)!  """  myField: String!  otherField(    "Description for argument"    arg: Int  )}</pre><p>文档完善的schema可以提升开发者体验，因为GraphQL开发者工具（例如Apollo VS Code extension 和 GraphQL Playground）可以根据我们提供的描述自动填写字段名。而且 Apollo Studio在使用其指标报告和客户端感知功能时，会在字段使用情况和性能详细信息的旁边显示说明</p><h5 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h5><p>GraphQL规范是很灵活的而且不强制特定的命名规范。但是在组织中建立一个约定集合确保持续集成是很有用的。我们推荐如下：</p><ul><li>字段名 使用<code>camelCase</code>命名。大部分GraphQL客户端都使用 JavaScript, Java, Kotlin, or Swift，我们都推荐使用<code>camelCase</code>命名变量名</li><li>类型名 使用<code>PascalCase</code>命名。这与上述语言中定义类的方式匹配</li><li>枚举名 使用<code>PascalCase</code></li><li>枚举值 使用<code>ALL_CAPS</code>，因为它们类似于常量</li></ul><p>这些约定有助于确保大多数客户端不需要定义额外的逻辑即可转换服务器返回的结果</p><h5 id="query-驱动的Schema设计"><a href="#query-驱动的Schema设计" class="headerlink" title="query 驱动的Schema设计"></a>query 驱动的Schema设计</h5><p>当GraphQL schema的执行操作是依据客户端的需求而设计时，其功能最为强大。尽管您可以构造类型，使它们与后端数据存储的结构匹配，但您duck不必这样！单个对象类型的字段可以许多不同来源的数据所填充。<strong>根据数据的使用方式（而不是数据的存储方式）设计Schema</strong>。</p><p>如果您的数据存储区包含客户端尚不需要的字段或关系，请从您的Schema中将其忽略。向Schema中添加新字段比删除某些客户端正在使用的现有字段更加容易和安全。</p><p><strong>query 驱动的Schema设计示例</strong><br>假设我们正在创建一个Web应用程序，其中列出了我们地区内的近期活动。我们希望该应用显示每个事件的名称，日期和位置，以及天气预报。</p><p>在这种情况下，我们希望Web应用能够执行具有类似于以下内容的结构的查询</p><pre>query EventList {  upcomingEvents {    name    date    location {      name      weather {        temperature        description      }    }  }}</pre><p>因为我们知道这是对我们的客户有帮助的数据结构，所以我们可以这样设计schema的结构：</p><pre>type Query {  upcomingEvents: [Event]}type Event {  name: String  date: String  location: Location}type Location {  name: String  weather: WeatherInfo}type WeatherInfo {  temperature: Float  description: String}</pre><p>如上所述，可以使用来自不同数据源（或多个数据源）的数据填充每一个类型中。例如，该<code>Event类型</code>的<code>name</code>和<code>date</code>字段可能从后端数据库获取``，而该WeatherInfo类型的可能来自第三方Weather API的数据。</p><h5 id="设计mutation"><a href="#设计mutation" class="headerlink" title="设计mutation"></a>设计mutation</h5><p>在GraphQL中，建议每个mutation的返回值都包含该mutation修改的数据。这使客户端无需发送后续查询即可获取最新的持久化数据。</p><p>一个Schema，支持更新email的User会包括以下内容：</p><pre> type Mutation {   # This mutation takes id and email parameters and responds with a User   updateUserEmail(id: ID!, email: String!): User } type User {   id: ID!   name: String!   email: String! }</pre><p>然后，客户端可以针对具有以下结构的schema执行mutation：</p><pre>mutation updateMyUser {  updateUserEmail(id: 1, email: "jane@example.com"){    id    name    email  }}</pre><p>GraphQL服务器执行更改并为用户存储新的电子邮件地址后，它将使用以下内容响应客户端：</p><pre>{  "data": {    "updateUserEmail": {      "id": "1",      "name": "Jane Doe",      "email": "jane@example.com"    }  }}</pre><p>虽然它不是强制性的mutation的返回包括修改的对象，这样大大提高了客户端代码的效率。与查询一样，确定哪些mutation对您的客户有用，这有助于告知架构的结构。</p><h6 id="构建mutation"><a href="#构建mutation" class="headerlink" title="构建mutation"></a>构建mutation</h6><p>单个mutation可以修改多种类型，或同一类型的多个实例。例如，使用户能够“喜欢”博客文章的mutation可能会增加<code>Post</code>的<code>likes</code>计数，并更新的<code>likedPosts</code>的<code>User</code>列表。这使得mutation返回的结构不太明晰。</p><p>此外，由于mutation会修改数据，因此比查询引起错误的可能性要高得多。mutation甚至可能导致部分错误，比如成功修改了一条数据而没有修改另一条数据。无论错误的类型如何，以一致的方式将错误传达回客户端都是很重要的。</p><p>为帮助解决这两个问题，建议您在架构中定义一个<code>MutationResponse</code>接口，以及用对象类型的集合实现该接口（每个mutation一个）。</p><p>下面是什么MutationResponse接口的样子：</p><pre>interface MutationResponse {  code: String!  success: Boolean!  message: String!}</pre><p>这是一个实现对象类型：</p><pre>type UpdateUserEmailMutationResponse implements MutationResponse {  code: String!  success: Boolean!  message: String!  user: User}</pre><p>我们的updateUserEmail的mutation将指定UpdateUserEmailMutationResponse为返回类型（而不是User），其响应的结构如下：</p><pre>{  "data": {    "updateUser": {      "code": "200",      "success": true,      "message": "User email was successfully updated",      "user": {        "id": "1",        "name": "Jane Doe",        "email": "jane@example.com"      }    }  }}</pre><p>让我们按字段细分：</p><ul><li>code是代表数据传输状态的字符串。可以将其视为HTTP状态代码。</li><li>success是一个布尔值，指示mutation是否成功。这允许客户端进行粗略检查，以了解是否存在故障。</li><li>message是描述mutation结果的可读性字符串。可以在产品的UI中使用。</li><li>user由实现类型添加，UpdateUserEmailMutationResponse以将新更新的用户返回给客户端。</li></ul><p>如果mutation修改多种类型（例如我们前面的“喜欢”博客文章的示例），则其实现类型可以为每个被修改的类型包括一个单独的字段：</p><pre>type LikePostMutationResponse implements MutationResponse {  code: String!  success: Boolean!  message: String!  post: Post  user: User}</pre><p>由于我们的假设likePost会同时修改Post和User，因此其返回对象包括这两种类型的字段。返回值具有以下结构：</p><pre>{  "data": {    "likePost": {      "code": "200",      "success": true,      "message": "Thanks!",      "post": {        "id": "123",        "likes": 5040      },      "user": {        "likedPosts": ["123"]      }    }  }}</pre><p>遵循此模式为客户端关每个请求的操作结果提供有用的详细信息。有了这些信息，开发人员可以更好地应对其客户端代码中的操作失败。</p><h4 id="自定义标量类型和枚举类型"><a href="#自定义标量类型和枚举类型" class="headerlink" title="自定义标量类型和枚举类型"></a>自定义标量类型和枚举类型</h4><h2 id="为schema添加自定义标量和枚举类型"><a href="#为schema添加自定义标量和枚举类型" class="headerlink" title="为schema添加自定义标量和枚举类型"></a>为schema添加自定义标量和枚举类型</h2><p>该GraphQL规范包括以下默认标量类型：<code>Int</code>，<code>Float</code>，<code>String</code>，<code>Boolean</code>和<code>ID</code>。尽管这涵盖了大多数用例，但有些需要支持自定义<br>原子数据类型（例如Date），或向现有类型添加验证。为此，GraphQL允许自定义标量类型。枚举类似于自定义标量，其限制是它们的值只能是字符串的预定义列表之一。</p><h5 id="自定义标量"><a href="#自定义标量" class="headerlink" title="自定义标量"></a>自定义标量</h5><p>要定义自定义标量，请使用以下符号将其添加到Schema字符串：</p><pre>scalar MyCustomScalar</pre><p>然后，在resolver map中<code>MyCustomScalar</code>通过GraphQLScalarType传递类的实例，定义自定义标量的行为。可以使用依赖项或源代码定义此实例。</p><p>有关GraphQL类型系统的更多信息，请参考官方文档或学习GraphQL教程。</p><p>请注意，Apollo Client当前并不能自动解析自定义标量，因此无法自动在客户端上逆转序列化。</p><h6 id="使用-package"><a href="#使用-package" class="headerlink" title="使用 package"></a>使用 package</h6><p>在这里，我们以<code>graphql-type-json</code>包为例，演示可以做什么。此npm包定义了JSON GraphQL标量类型。</p><p>将graphql-type-json包添加到项目的依赖项中：</p><pre>$ npm install graphql-type-json</pre><p>在代码中，要求使用npm包中定义的类型并使用它：</p><pre>const { ApolloServer, gql } = require('apollo-server');const GraphQLJSON = require('graphql-type-json');const schemaString = gql`  scalar JSON  type Foo {    aField: JSON  }  type Query {    foo: Foo  }`;const resolveFunctions = {  JSON: GraphQLJSON};const server = new ApolloServer({ typeDefs: schemaString, resolvers: resolveFunctions });server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><p>备注：<code>GraphQLJSON</code>是一个<code>GraphQLScalarType</code>实例。</p><h6 id="自订执行GraphQLScalarType个体"><a href="#自订执行GraphQLScalarType个体" class="headerlink" title="自订执行GraphQLScalarType个体"></a>自订执行GraphQLScalarType个体</h6><p>定义GraphQLScalarType实例可以提供对自定义标量的更多控制，并且可以通过以下方式将其添加到Apollo服务器：</p><pre>const { ApolloServer, gql } = require('apollo-server');const { GraphQLScalarType, Kind } = require('graphql');const myCustomScalarType = new GraphQLScalarType({  name: 'MyCustomScalar',  description: 'Description of my custom scalar type',  serialize(value) {    let result;    // Implement custom behavior by setting the 'result' variable    return result;  },  parseValue(value) {    let result;    // Implement custom behavior here by setting the 'result' variable    return result;  },  parseLiteral(ast) {    switch (ast.kind) {      case Kind.Int:      // return a literal value, such as 1 or 'static string'    }  }});const schemaString = gql`  scalar MyCustomScalar  type Foo {    aField: MyCustomScalar  }  type Query {    foo: Foo  }`;const resolverFunctions = {  MyCustomScalar: myCustomScalarType};const server = new ApolloServer({ typeDefs: schemaString, resolvers: resolverFunctions });server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><h5 id="自定义标量示例"><a href="#自定义标量示例" class="headerlink" title="自定义标量示例"></a>自定义标量示例</h5><p>让我们看几个示例，以演示如何定义自定义标量类型。</p><h5 id="日期标量"><a href="#日期标量" class="headerlink" title="日期标量"></a>日期标量</h5><p>目标是定义Date用于Date从数据库返回值的数据类型。假设我们正在使用使用本机JavaScript Date数据类型的MongoDB驱动程序。Date使用getTime()方法可<br>以轻松地将数据类型序列化为数字。因此，我们希望GraphQL服务器Date在序列化为JSON时以数字形式发送和接收。此数字将解析为Date服务器上代表日期值的。在<br>客户端上，用户可以简单地根据接收到的数值创建一个新日期。</p><p>下面是我们来实现<code>Date</code>数据类型， 首先在Schema</p><pre>const typeDefs = gql`  scalar Date  type MyType {    created: Date  }`</pre><p>接下来是解析器</p><pre>const { GraphQLScalarType } = require('graphql');const { Kind } = require('graphql/language');const resolvers = {  Date: new GraphQLScalarType({    name: 'Date',    description: 'Date custom scalar type',    parseValue(value) {      return new Date(value); // value from the client    },    serialize(value) {      return value.getTime(); // value sent to the client    },    parseLiteral(ast) {      if (ast.kind === Kind.INT) {        return parseInt(ast.value, 10); // ast value is always in string format      }      return null;    },  }),};const server = new ApolloServer({ typeDefs, resolvers });server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><p>在这个例子中，我们会根据<a href="https://www.npmjs.com/package/graphql" target="_blank" rel="noopener">graphql</a>官方文档的标量类型来陈述GraphQL如何校验数据库中为奇数数字段，首先Schema，</p><pre>const typeDefs = gql`  scalar Odd  type MyType {    oddValue: Odd  }`</pre><p>下一步，resolver：</p><pre>const { ApolloServer, gql } = require('apollo-server');const { GraphQLScalarType } = require('graphql');const { Kind } = require('graphql/language');function oddValue(value) {  return value % 2 === 1 ? value : null;}const resolvers = {  Odd: new GraphQLScalarType({    name: 'Odd',    description: 'Odd custom scalar type',    parseValue: oddValue,    serialize: oddValue,    parseLiteral(ast) {      if (ast.kind === Kind.INT) {        return oddValue(parseInt(ast.value, 10));      }      return null;    },  }),};const server = new ApolloServer({ typeDefs, resolvers });server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>枚举类型和标量类型很相似，但是枚举类型只能定义Schema中一部分值。枚举类型在比如用户需要在列表清单做选择是这种情况下很适用。除此之外，枚举类型可以提高开发速度，<br>因为他们可以在像GraphQL Playground工具中自动带入。<br>在 Schema 中， 一个枚举类型如下</p><pre>enum AllowedColor {  RED  GREEN  BLUE}</pre><p>枚举类型可以用在任何标量类型可以用位置</p><pre>type Query {  favoriteColor: AllowedColor # As a return value  avatar(borderColor: AllowedColor): String # As an argument}</pre><p>使用JSON串把枚举值作为变量传递：</p><pre>query GetAvatar($color: AllowedColor) {  avatar(borderColor: $color)}</pre><pre>{  "color": "RED"}</pre><p>整合在一起</p><pre>const { ApolloServer, gql } = require('apollo-server');const typeDefs = gql`  enum AllowedColor {    RED    GREEN    BLUE  }  type Query {    favoriteColor: AllowedColor # As a return value    avatar(borderColor: AllowedColor): String # As an argument  }`;const resolvers = {  Query: {    favoriteColor: () => 'RED',    avatar: (parent, args) => {      // args.borderColor is 'RED', 'GREEN', or 'BLUE'    },  }};const server = new ApolloServer({ typeDefs, resolvers });server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><h6 id="内部值"><a href="#内部值" class="headerlink" title="内部值"></a>内部值</h6><p>有时后端在内部为枚举强制使用与公共API中不同的枚举值。在此示例中，API包含<code>RED</code>，但是我们在resolvers使用#f00代替。在<code>resolvers</code>ApolloServer传参时允许<br>给枚举添加自定义的值：</p><pre>const resolvers = {  AllowedColor: {    RED: '#f00',    GREEN: '#0f0',    BLUE: '#00f',  }};</pre><p>这些根本不更改公共API，resolvers接受内部值而不是Schema值，如下所示：</p><pre>const resolvers = {  AllowedColor: {    RED: '#f00',    GREEN: '#0f0',    BLUE: '#00f',  },  Query: {    favoriteColor: () => '#f00',    avatar: (parent, args) => {      // args.borderColor is '#f00', '#0f0', or '#00f'    },  }};</pre><p>在大多数情况下，除非有另一个库进行互操作期望值有不同的表现形式，否则不会使用枚举的此功能。</p><h4 id="Unions-和-interfaces"><a href="#Unions-和-interfaces" class="headerlink" title="Unions 和 interfaces"></a>Unions 和 interfaces</h4><p>如何在Schema中添加 Unions 和 interfaces </p><p>当同一字段拥有不同类型是，Unions 和 interfaces是非常强大的</p><h5 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h5><p><code>Unions</code>类型认为一个字段可以返回至少一个对象类型，但是字段本身没有准确的类型。<code>Unions</code>类型对从单个字段返回的不相关数据类型非常有用。<br>类型定义如下所示</p><pre>const { gql } = require('apollo-server');const typeDefs = gql`  union Result = Book | Author  type Book {    title: String  }  type Author {    name: String  }  type Query {    search: [Result]  }`;</pre><p>由于查询请求联合字段，因此对联合类型的字段进行的查询必须指定包含所需字段的对象类型。通过__resolveType解析器图中的一个额外字段解决了这种歧义。<br>__resolveType定义结果的类型超出GraphQL执行环境的可用选项。</p><pre>const resolvers = {  Result: {    __resolveType(obj, context, info){      if(obj.name){        return 'Author';      }      if(obj.title){        return 'Book';      }      return null;    },  },  Query: {    search: () => { ... }  },};const server = new ApolloServer({  typeDefs,  resolvers,});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><p>对于这些结果的可能查询如下所示。该查询表明需要使用__resolveType，因为它会根据类型请求不同的数据，</p><pre>{  search(contains: "") {    ... on Book {      title    }    ... on Author {      name    }  }}</pre><h5 id="interface-类型"><a href="#interface-类型" class="headerlink" title="interface 类型"></a>interface 类型</h5><p>interface 类型是当使用抽象类型来构建和使用GraphQL Schemas 的有效方法。抽象类型不能直接在Schema中使用，但可以用构建块来创建显式类型。<br>想想当其中不同类型的书共享一组共同的属性，例如课本和涂色书。这些书可以用 interface 类型来构建：</p><pre>interface Book {  title: String  author: Author}</pre><p>当然，我们不能直接使用此interface类型来查询书籍，但可以使用它来实现具体类型。想象一下应用程序中页面，该页面要显示所有书籍的提要，而无需关心具体<br>类型。要创建此类功能，我们可以定义以下内容：</p><pre>type TextBook implements Book {  title: String  author: Author  classes: [Class]}type ColoringBook implements Book {  title: String  author: Author  colors: [Color]}type Query {  schoolBooks: [Book]}</pre><p>在此示例中，我们已使用<code>Book</code> interface 作为<code>TexBook</code> 和<code>ColoringBook</code>的基础类型。schoolBooks字段表示返回一个书列表（即[Book]）。</p><p>与Union 类型类似，在resolver映射中Interface类型需要一个额外的<code>__resolveType</code>字段来确定需要处理为哪种类型。</p><pre>const resolvers = {  Book: {    __resolveType(book, context, info){      if(book.classes){        return 'TextBook';      }      if(book.colors){        return 'ColoringBook';      }      return null;    },  },  Query: {    schoolBooks: () => { ... }  },};</pre><p>现在，我们简化了实现Book的过程，是因为消除了返回何种类型Book的疑虑。根据Schema的查询可能返回以下内容：TextBook和ColoringBook</p><pre>query GetBooks {  schoolBooks {    title    author  }}</pre><p>这对于常见内容、用户角色系统等都非常有帮助!<br>此外，如果我们需要返回的字段仅由TextBooks或ColoringBooks（不是两者都提供）提供，则可以从查询中的抽象类型请求片段。这些片段要根据具体条件填写；<br>如下，仅会向ColoringBook返回colors，而只有TextBook具有classes：</p><pre>query GetBooks {  schoolBooks {    title    ... on TextBook {      classes {        name      }    }    ... on ColoringBook {      colors {        name      }    }  }}</pre><h4 id="使用schema指令"><a href="#使用schema指令" class="headerlink" title="使用schema指令"></a>使用schema指令</h4><p>使用schema指令可以转变Schema类型、字段、参数</p><p>指令是由标识符<code>@</code>，命名参数可选，其后可出现任何符合GraphQL query或schema 语言的语法的形式。下面是 GraphQL规范草案的示例，说明了<br>其中几种可能性：</p><pre>directive @deprecated(  reason: String = "No longer supported") on FIELD_DEFINITION | ENUM_VALUEtype ExampleType {  newField: String  oldField: String @deprecated(reason: "Use `newField`.")}</pre><p>正如你所看到的，使用<code>@deprecated(reason: ...)</code> 属于（oldField），这个语法可能会让你想起其他语言中“装饰器”。<br>指令通过<code>directive @deprecated ... on ...</code>声明，使用@deprecated(reason: …)语法使用。</p><h5 id="默认指令"><a href="#默认指令" class="headerlink" title="默认指令"></a>默认指令</h5><p>GraphQL提供数个指令：@deprecated，@skip，和@include。</p><ul><li>@deprecated(reason: String) -将字段标记为已弃用消息</li><li>@skip(if: Boolean!) -GraphQL将通过不调用解析器来跳过该字段（如果为true）</li><li>@include(if: Boolean!) -如果为true，则为带注释的字段调用解析器<h5 id="使用自定义Schema指令"><a href="#使用自定义Schema指令" class="headerlink" title="使用自定义Schema指令"></a>使用自定义Schema指令</h5>要使用自定义Schema指令，请通过<code>schemaDirectives</code>参数将执行类传递给Apollo Server，该参数是一个将指令名称映射到执行指令的对象：<pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require('apollo-server');const { defaultFieldResolver } = require('graphql');</li></ul><p>// Create (or import) a custom schema directive<br>class UpperCaseDirective extends SchemaDirectiveVisitor {<br>  visitFieldDefinition(field) {<br>    const { resolve = defaultFieldResolver } = field;<br>    field.resolve = async function (…args) {<br>      const result = await resolve.apply(this, args);<br>      if (typeof result === ‘string’) {<br>        return result.toUpperCase();<br>      }<br>      return result;<br>    };<br>  }<br>}</p><p>// Construct a schema, using GraphQL schema language<br>const typeDefs = gql`<br>  directive @upper on FIELD_DEFINITION</p><p>  type Query {<br>    hello: String @upper<br>  }<br>`;</p><p>// Provide resolver functions for your schema fields<br>const resolvers = {<br>  Query: {<br>    hello: (parent, args, context) =&gt; {<br>      return ‘Hello world!’;<br>    },<br>  },<br>};</p><p>// Add directive to the ApolloServer constructor<br>const server = new ApolloServer({<br>  typeDefs,<br>  resolvers,<br>  schemaDirectives: {<br>    upper: UpperCaseDirective,<br>  }<br>});</p><p>server.listen().then(({ url }) =&gt; {<br>  console.log(<code>🚀 Server ready at ${url}</code>)<br>});<br></pre><br>实现UpperCaseDirective负责更改解析器并在必要时修改schema。</p><h5 id="创建自己的指令"><a href="#创建自己的指令" class="headerlink" title="创建自己的指令"></a>创建自己的指令</h5><p>先要了解应用自己Schema指令，请阅读下面文档</p><h4 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h4><p>执行自定义指令去转换Schema类型，字段和参数<br>在学习如何执行schema指令之前，本节将提供关于Schema指令及其使用的必要背景。</p><h4 id="Schema执行指令"><a href="#Schema执行指令" class="headerlink" title="Schema执行指令"></a>Schema执行指令</h4><p>由于GraphQL规范未讨论指令的任何特定执行策略，因此由每个GraphQL服务器框架暴露用于执行新指令的API。</p><p>如果使用的是Apollo Server，则使用的是<code>graphql-tools</code>npm包，该包提供了一个方便而强大的工具来实现指令语法：SchemaDirectiveVisitor类。</p><p>要使用<code>SchemaDirectiveVisitor</code>来执行Schema指令，只需创建一个SchemaDirectiveVisitor子类将覆盖以下一个或多个访问器方法：</p><ul><li>visitSchema(schema: GraphQLSchema)</li><li>visitScalar(scalar: GraphQLScalarType)</li><li>visitObject(object: GraphQLObjectType)</li><li>visitFieldDefinition(field: GraphQLField&lt;any, any&gt;)</li><li>visitArgumentDefinition(argument: GraphQLArgument)</li><li>visitInterface(iface: GraphQLInterfaceType)</li><li>visitUnion(union: GraphQLUnionType)</li><li>visitEnum(type: GraphQLEnumType)</li><li>visitEnumValue(value: GraphQLEnumValue)</li><li>visitInputObject(object: GraphQLInputObjectType)</li><li>visitInputFieldDefinition(field: GraphQLInputField)</li></ul><p>通过扩展<code>visitObject</code>的方法，SchemaDirectiveVisitor的子类表达了对某些schema类型（例如GraphQLObjectType的第一个参数类型visitObject）的兴趣。</p><p>这些方法名称对应于schema中使用指令的所有可能位置。例如，<code>INPUT_FIELD_DEFINITION</code>位置由处理<code>visitInputFieldDefinition</code>。</p><p>这是@deprecated我们在上面看到的一种执行指令：</p><pre>const { SchemaDirectiveVisitor } = require("apollo-server");class DeprecatedDirective extends SchemaDirectiveVisitor {  public visitFieldDefinition(field: GraphQLField<any, any>) {    field.isDeprecated = true;    field.deprecationReason = this.args.reason;  }  public visitEnumValue(value: GraphQLEnumValue) {    value.isDeprecated = true;    value.deprecationReason = this.args.reason;  }}</pre><p>为了将此执行应用于包含@deprecated指令的schema，只需DeprecatedDirective通过以下schemaDirectives选项将类传递给Apollo Server的构造函数即可：</p><pre>const { ApolloServer, gql } = require("apollo-server");const typeDefs = gql`  type ExampleType {    newField: String    oldField: String @deprecated(reason: "Use \`newField\`.")  }`;const server = new ApolloServer({  typeDefs,  resolvers,  schemaDirectives: {    deprecated: DeprecatedDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>另外，如果要修改现有的schema对象，则可以直接调用<code>SchemaDirectiveVisitor.visitSchemaDirectives</code>接口：</p><pre>SchemaDirectiveVisitor.visitSchemaDirectives(schema, {  deprecated: DeprecatedDirective});</pre><p>请注意，该<code>@deprecated</code>指令的不同次出现可能会使<code>SchemaDirectiveVisitor</code>的子类会被多次实例化。这就是为什么提供一个类而不是该类的实例的原因。</p><p>如果由于某种原因您有使用schema中该<code>@deprecated</code>指令的其他名名称，但又想使用相同的执行，则可以！DeprecatedDirective只需更改schemaDirectives传递给<br>Apollo Server 构造函数的对象中的键，即可使用不同的名称传递相同的类。换句话说，SchemaDirectiveVisitor实现实际上是匿名的，因此由使用它们来为其分配名称的人来决定。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>为了了解带来的各种可能性SchemaDirectiveVisitor，让我们研究各种实际示例</p><h6 id="大写字符串"><a href="#大写字符串" class="headerlink" title="大写字符串"></a>大写字符串</h6><p>假设您要将字符串值字段转换为大写。尽管此用例很简单，但它是通过包装字段的<code>resolve</code>函数执行指令的一个很好的例子：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const { defaultFieldResolver } = require("graphql");const typeDefs = gql`  directive @upper on FIELD_DEFINITION  type Query {    hello: String @upper  }`;class UpperCaseDirective extends SchemaDirectiveVisitor {  visitFieldDefinition(field) {    const { resolve = defaultFieldResolver } = field;    field.resolve = async function (...args) {      const result = await resolve.apply(this, args);      if (typeof result === "string") {        return result.toUpperCase();      }      return result;    };  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    upper: UpperCaseDirective,    upperCase: UpperCaseDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>注意@upper，@upperCase使用相同的UpperCaseDirective实现来处理这两个过程非常容易。</p><p>######从REST API获取数据<br>假设您已经定义了一个与REST资源相对应的对象类型，并且您想要避免为每个字段实现解析器功能：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const typeDefs = gql`  directive @rest(url: String) on FIELD_DEFINITION  type Query {    people: [Person] @rest(url: "/api/v1/people")  }`;class RestDirective extends SchemaDirectiveVisitor {  public visitFieldDefinition(field) {    const { url } = this.args;    field.resolve = () => fetch(url);  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    rest: RestDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>在REST端点上实现真正的GraphQL包装时，还有许多其他问题需要考虑（例如，如何进行缓存或分页），但是此示例演示了一个基本思路。</p><h6 id="匹配日期字符串"><a href="#匹配日期字符串" class="headerlink" title="匹配日期字符串"></a>匹配日期字符串</h6><p>假设你的解析器返回的是一个 Date对象，但是在客户端需要返回字符串类型</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const typeDefs = gql`  directive @date(format: String) on FIELD_DEFINITION  scalar Date  type Post {    published: Date @date(format: "mmmm d, yyyy")  }`;class DateFormatDirective extends SchemaDirectiveVisitor {  visitFieldDefinition(field) {    const { resolve = defaultFieldResolver } = field;    const { format } = this.args;    field.resolve = async function (...args) {      const date = await resolve.apply(this, args);      return require('dateformat')(date, format);    };    // The formatted Date becomes a String, so the field type must change:    field.type = GraphQLString;  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    date: DateFormatDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>当然，如果Schema的维护者并没有确定具体的Date类型，你可以把这个交给客户端处理会更好一些。为了做到这一点，我们为相应的字段的指令加上参数即可</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const formatDate = require("dateformat");const { defaultFieldResolver, GraphQLString } = require("graphql");const typeDefs = gql`  directive @date(    defaultFormat: String = "mmmm d, yyyy"  ) on FIELD_DEFINITION  scalar Date  type Query {    today: Date @date  }`;class FormattableDateDirective extends SchemaDirectiveVisitor {  public visitFieldDefinition(field) {    const { resolve = defaultFieldResolver } = field;    const { defaultFormat } = this.args;    field.args.push({      name: 'format',      type: GraphQLString    });    field.resolve = async function (      source,      { format, ...otherArgs },      context,      info,    ) {      const date = await resolve.call(this, source, otherArgs, context, info);      // If a format argument was not provided, default to the optional      // defaultFormat argument taken by the @date directive:      return formatDate(date, format || defaultFormat);    };    field.type = GraphQLString;  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    date: FormattableDateDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>现在，当请求<code>Query.today</code>字段，客户端可以在Schema中指定<code>format</code>参数，或者使用默认<code>defaultFormat</code></p><pre>const { request } = require("graphql-request");server.listen().then(({ url }) => {  request(url, `query { today }`).then(result => {    // Logs with the default "mmmm d, yyyy" format:    console.log(result.data.today);  });  request(url, `query {    today(format: "d mmm yyyy")  }`).then(result => {    // Logs with the requested "d mmm yyyy" format:    console.log(result.data.today);  });})</pre><h6 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h6><p>假设你有一个``translate`函数，该函数需要一个字符串，一个标识该字符串在应用程序中角色路径，和需要转换的目标语言环境。</p><p>您可以按照以下方式确定<code>translate</code>用于本地化类型的<code>greeting</code>字段<code>Query</code></p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const typeDefs = gql`  directive @intl on FIELD_DEFINITION  type Query {    greeting: String @intl  }`;class IntlDirective extends SchemaDirectiveVisitor {  visitFieldDefinition(field, details) {    const { resolve = defaultFieldResolver } = field;    field.resolve = async function (...args) {      const context = args[2];      const defaultText = await resolve.apply(this, args);      // In this example, path would be ["Query", "greeting"]:      const path = [details.objectType.name, field.name];      return translate(defaultText, path, context.locale);    };  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    intl: IntlDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>GraphQL很适合做国际化，因为GraphQL server 没有限制访问的翻译数据，客户端只要按需请求即可</p><h6 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h6><p>假设我们有一个 @auth 指令，他接收<code>requires</code>参数是<code>Role</code>枚举类，默认类型是<code>ADMIN</code>。这个@auth指令作用于<code>OBJECT</code>（像<code>User</code>类型）<br>对所有的User类型 或者 特定的类型 设置访问权限。</p><pre>directive @auth(  requires: Role = ADMIN,) on OBJECT | FIELD_DEFINITIONenum Role {  ADMIN  REVIEWER  USER  UNKNOWN}type User @auth(requires: USER) {  name: String  banned: Boolean @auth(requires: ADMIN)  canPost: Boolean @auth(requires: REVIEWER)}</pre><p>使这个示例棘手的是，指令需要<code>OBJECT</code>的版本包装着对象的所有字段，即使其中某些字段可能<code>@auth</code>在该<code>FIELD_DEFINITION</code>级别由指令单独包装，<br>并且如果我们可以自己处理的话，最好不要重新包装解析器：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");class AuthDirective extends SchemaDirectiveVisitor {  visitObject(type) {    this.ensureFieldsWrapped(type);    type._requiredAuthRole = this.args.requires;  }  // Visitor methods for nested types like fields and arguments  // also receive a details object that provides information about  // the parent and grandparent types.  visitFieldDefinition(field, details) {    this.ensureFieldsWrapped(details.objectType);    field._requiredAuthRole = this.args.requires;  }  ensureFieldsWrapped(objectType) {    // Mark the GraphQLObjectType object to avoid re-wrapping:    if (objectType._authFieldsWrapped) return;    objectType._authFieldsWrapped = true;    const fields = objectType.getFields();    Object.keys(fields).forEach(fieldName => {      const field = fields[fieldName];      const { resolve = defaultFieldResolver } = field;      field.resolve = async function (...args) {        // Get the required Role from the field first, falling back        // to the objectType if no Role is required by the field:        const requiredRole =          field._requiredAuthRole ||          objectType._requiredAuthRole;        if (! requiredRole) {          return resolve.apply(this, args);        }        const context = args[2];        const user = await getUser(context.headers.authToken);        if (! user.hasRole(requiredRole)) {          throw new Error("not authorized");        }        return resolve.apply(this, args);      };    });  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    auth: AuthDirective,    authorized: AuthDirective,    authenticated: AuthDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>这种方法的一个缺点是，它不能保证如果在<code>AuthDirective</code>调用之后将字段添加到<code>Schema</code>中时，字段会被包装，并且整个<br><code>getUser(context.headers.authToken)</code>虚构的API仍需要充实。换句话说，虽然我们忽略了执行该指令可用于生产环境的所需要的一些细节，但是我们希望<br>此处显示的基本结构能够激发您找到解决现存问题解决方案。</p><h6 id="值限制"><a href="#值限制" class="headerlink" title="值限制"></a>值限制</h6><p>假设您要为字符串值字段设置最大长度：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require('apollo-server');const { GraphQLScalarType, GraphQLNonNull } = require('graphql');const typeDefs = gql`  directive @length(max: Int) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION  type Query {    books: [Book]  }  type Book {    title: String @length(max: 50)  }  type Mutation {    createBook(book: BookInput): Book  }  input BookInput {    title: String! @length(max: 50)  }`;class LengthDirective extends SchemaDirectiveVisitor {  visitInputFieldDefinition(field) {    this.wrapType(field);  }  visitFieldDefinition(field) {    this.wrapType(field);  }  // Replace field.type with a custom GraphQLScalarType that enforces the  // length restriction.  wrapType(field) {    if (      field.type instanceof GraphQLNonNull &&      field.type.ofType instanceof GraphQLScalarType    ) {      field.type = new GraphQLNonNull(        new LimitedLengthType(field.type.ofType, this.args.max),      );    } else if (field.type instanceof GraphQLScalarType) {      field.type = new LimitedLengthType(field.type, this.args.max);    } else {      throw new Error(`Not a scalar type: ${field.type}`);    }  }}class LimitedLengthType extends GraphQLScalarType {  constructor(type, maxLength) {    super({      name: `LengthAtMost${maxLength}`,      // For more information about GraphQLScalar type (de)serialization,      // see the graphql-js implementation:      // https://github.com/graphql/graphql-js/blob/31ae8a8e8312/src/type/definition.js#L425-L446      serialize(value) {        value = type.serialize(value);        assert.isAtMost(value.length, maxLength);        return value;      },      parseValue(value) {        return type.parseValue(value);      },      parseLiteral(ast) {        return type.parseLiteral(ast);      },    });  }}const server = new ApolloServer({  typeDefs,  resolvers,  schemaDirectives: {    length: LengthDirective,  },});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><h6 id="生成唯一ID"><a href="#生成唯一ID" class="headerlink" title="生成唯一ID"></a>生成唯一ID</h6><p>假设您的数据库对每种资源类型都使用递增ID，而且ID在所有资源类型中都不都是唯一的。您可以通过以下方法合成一个名为的字段uid，该字段将对象类型与各<br>种字段值结合在一起，以产生一个在整个Schema中唯一的ID：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const { GraphQLID } = require("graphql");const { createHash } = require("crypto");const typeDefs = gql`  directive @uniqueID(    # The name of the new ID field, "uid" by default:    name: String = "uid"    # Which fields to include in the new ID:    from: [String] = ["id"]  ) on OBJECT  # Since this type just uses the default values of name and from,  # we don't have to pass any arguments to the directive:  type Location @uniqueID {    id: Int    address: String  }  # This type uses both the person's name and the personID field,  # in addition to the "Person" type name, to construct the ID:  type Person @uniqueID(from: ["name", "personID"]) {    personID: Int    name: String  }`;class UniqueIdDirective extends SchemaDirectiveVisitor {  visitObject(type) {    const { name, from } = this.args;    const fields = type.getFields();    if (name in fields) {      throw new Error(`Conflicting field name ${name}`);    }    fields[name] = {      name,      type: GraphQLID,      description: 'Unique ID',      args: [],      resolve(object) {        const hash = createHash("sha1");        hash.update(type.name);        from.forEach(fieldName => {          hash.update(String(object[fieldName]));        });        return hash.digest("hex");      }    };  }}const server = new ApolloServer({  typeDefs,  resolvers,  schemaDirectives: {    uniqueID: UniqueIdDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><h5 id="声明Schema指令"><a href="#声明Schema指令" class="headerlink" title="声明Schema指令"></a>声明Schema指令</h5><p>尽管上述例足以执行你在Schema中使用的任何<code>@directive</code>，但是SDL 预发还支持声明名称，参数类型，默认参数以及允许使用指令的位置</p><pre>directive @auth(  requires: Role = ADMIN,) on OBJECT | FIELD_DEFINITIONenum Role {  ADMIN  REVIEWER  USER  UNKNOWN}type User @auth(requires: USER) {  name: String  banned: Boolean @auth(requires: ADMIN)  canPost: Boolean @auth(requires: REVIEWER)}</pre><p>该假设@auth指令参数为requires，参数类型为Role，如果<code>@auth</code>不传递显式requires参数默认值是ADMIN，。该@auth指令可以出现在像<code>User</code>这样<br>的<code>OBJECT</code>上，为所有User字段设置默认访问控制，也可以在单个字段上限制。</p><p>从理论上讲满足声明的要求是<code>SchemaDirectiveVisitor</code>执行本身可以完成的事情，但是SDL语法更易于读写，即使没有使用SchemaDirectiveVisitor抽象也可以提供值。</p><p>但是，如果要实现可重用SchemaDirectiveVisitor的公共用途，则可能不是编写SDL语法的人，因此您可能无法控制schema开发者决定声明哪些指令以及如何声明。<br>这就是为什么一个执行良好，可重用<code>SchemaDirectiveVisitor</code>的方法应该考虑重写<code>getDirectiveDeclaration</code>方法：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const { DirectiveLocation, GraphQLDirective, GraphQLEnumType } = require("graphql");class AuthDirective extends SchemaDirectiveVisitor {  public visitObject(object: GraphQLObjectType) {...}  public visitFieldDefinition(field: GraphQLField<any, any>) {...}  public static getDirectiveDeclaration(    directiveName: string,    schema: GraphQLSchema,  ): GraphQLDirective {    const previousDirective = schema.getDirective(directiveName);    if (previousDirective) {      // If a previous directive declaration exists in the schema, it may be      // better to modify it than to return a new GraphQLDirective object.      previousDirective.args.forEach(arg => {        if (arg.name === 'requires') {          // Lower the default minimum Role from ADMIN to REVIEWER.          arg.defaultValue = 'REVIEWER';        }      });      return previousDirective;    }    // If a previous directive with this name was not found in the schema,    // there are several options:    //    // 1. Construct a new GraphQLDirective (see below).    // 2. Throw an exception to force the client to declare the directive.    // 3. Return null, and forget about declaring this directive.    //    // All three are valid options, since the visitor will still work without    // any declared directives. In fact, unless you're publishing a directive    // implementation for public consumption, you can probably just ignore    // getDirectiveDeclaration altogether.    return new GraphQLDirective({      name: directiveName,      locations: [        DirectiveLocation.OBJECT,        DirectiveLocation.FIELD_DEFINITION,      ],      args: {        requires: {          // Having the schema available here is important for obtaining          // references to existing type objects, such as the Role enum.          type: (schema.getType('Role') as GraphQLEnumType),          // Set the default minimum Role to REVIEWER.          defaultValue: 'REVIEWER',        }      }]    });  }}</pre><p>由于<code>getDirectiveDeclaration</code>方法不仅接收指令的名称，而且还接收GraphQLSchema对象，因此它可以修改和/或重用在Schema中找到的先前的声明，作为替代方法返回<br>全新GraphQLDirective对象。无论哪种方式，如果访问者返回一个非空GraphQLDirective的getDirectiveDeclaration，该声明将被用来检查参<br>数和允许的位置。</p><h5 id="查询指令"><a href="#查询指令" class="headerlink" title="查询指令"></a>查询指令</h5><p>顾名思义，该SchemaDirectiveVisitor抽象经过专门设计，可以根据SDL文本中显示的指令来转换GraphQL schema。</p><p>虽然指令语法也可以出现在从客户端发送的GraphQL查询中，但是执行查询指令将需要查询文档的运行时转换。我们故意将这种实现方式限制为在服务器构造时进行转换。</p><p>我们相信，将这种逻辑限制在您的schema中比负担您的客户更加可持续，尽管您可能会想到实现查询指令的类似抽象。如果这种可能性成为您的需要，请告诉我们，<br>我们可能会考虑在这些工具的未来版本中支持查询指令。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
