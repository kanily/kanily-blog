<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>移动端适配方案</title>
    <link href="/2020/07/07/css/mobile/"/>
    <url>/2020/07/07/css/mobile/</url>
    
    <content type="html"><![CDATA[<p>###像素</p><h4 id="物理像素（设备像素）"><a href="#物理像素（设备像素）" class="headerlink" title="物理像素（设备像素）"></a>物理像素（设备像素）</h4><p>屏幕的物理像素，又被成为设备像素，是现实设备中最微小的物理部件，任何设备的屏幕的物理像素出厂时就确定了，且固定不变</p><h4 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h4><p>设备独立像素也成为密度无关像素，可以认为是计算机坐标的一个点，这个点可以代表一个可由程序使用的虚拟像素（例如css像素），然后有相关系统转换为物理像素</p><h4 id="设备像素比（devicePixelRatio）"><a href="#设备像素比（devicePixelRatio）" class="headerlink" title="设备像素比（devicePixelRatio）"></a>设备像素比（devicePixelRatio）</h4><p>简称dpr ，定义了物理像素和设备独立像素的对应关50系</p><pre>设备像素比 = 物理像素 / 独立设备像素以iphone6 为例  设备固有像素为 750 * 1334，设备宽度是 375 * 667，其 dpr 就是2可以通过 window.devicePixelRatio 获得dpr > 1 就是高清屏，一般dpr为整数</pre><h4 id="css像素"><a href="#css像素" class="headerlink" title="css像素"></a>css像素</h4><p>css、js中使用的一个长度单位。单位 px</p><p>注意：pc端1物理像素 等于1px，但是移动端1物理像素不等于 1px，1物理像素与 px的关系与以下因素有关</p><pre>1.屏幕布局的视口大小2.屏幕的分辨率（物理像素）</pre><p>对于一块屏幕，其物理像素是确定的。视觉视口尺寸是继承与布局视口的，而视觉视口里的宽度即是css的px数。故一块屏幕上的物理像素与px的关系就是物理像素与布局视口的px数的关系</p><pre><code class="hljs plain">比如 iPhone6 它的物理像素是750px， 如果没有设置布局视口 viewport 为 980px此时: 1物理像素长度 &#x3D; 980px &#x2F; 750px &#x3D; 1.3076px 的长度由于像素都是点阵的 一个物理像素点相当度 1.3076px * 1.3076px 方格当在meta中设置了如下配置时 &lt;meta name &#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt; 相当于把布局视口设置为设备的宽度（即上面讲到的设备独立像素）， 对于iphone6就是375此时： 1物理像素长度 &#x3D; 375px &#x2F; 750px &#x3D; 0.5 的长度，相当于 0.5px * 0.5px 方格</code></pre><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><h4 id="1-布局视口"><a href="#1-布局视口" class="headerlink" title="1.布局视口"></a>1.布局视口</h4><p> 在html中一般在meta中的name为viewport 字段就是控制的布局视口，布局视口一般都是浏览器厂商给的一个值。但是浏览器厂商一般为了能小屏幕也能友好的展示，把布局视口设置很大，一般在768px~1024ox之间，最常用的就是980px。这样用户就能看大绝大部分的内容，根据内容去缩放</p><p> 故布局视口是看不见的，浏览器厂商设置的固定值，eg：980px，并将980px内容缩放到手机屏幕内</p><p> 布局视口可以通过</p><pre><code class="hljs plain">document.documentElement.clientWidth</code></pre><h4 id="2-视觉视口"><a href="#2-视觉视口" class="headerlink" title="2.视觉视口"></a>2.视觉视口</h4><p>浏览器可视区域的大小，即用户可以看到的区域。（其宽度继承于布局视口的宽度）</p><pre><code class="hljs plain">window.innerwidth</code></pre><h4 id="3-理想视口"><a href="#3-理想视口" class="headerlink" title="3.理想视口"></a>3.理想视口</h4><p>布局视口虽然解决了移动端 查看pc网页的问题，但是完全忽略的手机本身的尺寸。所以苹果引入了理想视口，它对于设备来说就是最理想的布局视口,用户不需要缩放就可以完美展示整个页面</p><p>可以通过</p><pre><code class="hljs plain">window.screen.width</code></pre><p>移动端到底如何适配呢 最简单就是设置如下视口</p><pre><code class="hljs plain">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,user-scalable&#x3D;no&quot;&gt;</code></pre><p>使用上述方案定义布局视时，即布局视口等于理想视口，屏幕没有滚动条，不存在高清屏下，字体较小的问题。但是在不同的屏幕上，视觉宽度是不同的，不能简单的将所有的尺寸都设置为px，</p><h4 id="viewport缩放"><a href="#viewport缩放" class="headerlink" title="viewport缩放"></a>viewport缩放</h4><p>对于上面设置，在不同的屏幕上，css像素对应的物理像素具体的数值是不一致的</p><p>在普通屏幕上 dpr = 1 时，<br>1个css像素长度对应一个物理像素长度，1个css像素对应一个物理像素</p><p>在retina屏幕， dpr = 2</p><p>1个css像素长度对应 2个物理像素长度， 一个css像素 对应 4个物理像素</p><h4 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h4><p>#####方案一<br>固定高度 宽度自适应</p><p>使用理想视口的方案</p><pre><code class="hljs plain">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minumum-scale&#x3D;1,user-scalable&#x3D;no&quot; &gt;</code></pre><p>垂直方向使用固定的值，水平方向使用弹性布局，元素使用定值 百分比 flex 布局</p><h5 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h5><p>固定布局视口宽度，使用viewport 缩放</p><pre><code class="hljs plain">if(&#x2F;Android (\d+\.\d+)&#x2F;.test(navigator.userAgent))&#123;  var version &#x3D; parseFloat(RegExp.$1);  if(version&gt;2.3)&#123;    var phoneScale &#x3D; parseInt(window.screen.width)&#x2F;640;    if(&#x2F;MZ-M571C&#x2F;.test(navigator.userAgent))&#123;      document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, minimum-scale &#x3D; 0.5, maximum-scale&#x3D; 0.5&quot;&gt;&#39;);    &#125;else if(&#x2F;M571C&#x2F;.test(navigator.userAgent)&amp;&amp;&#x2F;LizhiFM&#x2F;.test(navigator.userAgent))&#123;      document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, minimum-scale &#x3D; 0.5, maximum-scale&#x3D; 0.5&quot;&gt;&#39;);    &#125;else&#123;      document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, minimum-scale &#x3D; &#39;+ phoneScale +&#39;, maximum-scale &#x3D; &#39;+ phoneScale +&#39;, target-densitydpi&#x3D;device-dpi&quot;&gt;&#39;);    &#125;  &#125;else&#123;    document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, target-densitydpi&#x3D;device-dpi&quot;&gt;&#39;);  &#125;&#125;else&#123;  document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, user-scalable&#x3D;no, target-densitydpi&#x3D;device-dpi&quot;&gt;&#39;);&#125;</code></pre><p>方案三：</p><p>根据不同的屏幕动态写入font-size， 以rem作为宽度单位， 固定布局视口</p><pre><code class="hljs plain">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maxmum-scale&#x3D;1,user-scalable&#x3D;no&quot; &gt;</code></pre><p>以640px 设计稿 或者 750px 设计稿，</p><pre><code class="hljs plain">var width &#x3D; document.document.clientWidth;var rem &#x3D; width &#x2F; 7.5var rem width &#x2F; 6.4</code></pre><p>方案四 </p><p>以rem作为宽度单位，动态写入viewport 和 font-size 进行缩放</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Gallery</title>
    <link href="/2020/07/07/hello-world/"/>
    <url>/2020/07/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>摘要…</p><a id="more"></a><p>正文…</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><p><a href="source/data/promise/1.md">阅读更多…</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/BinarySearchTree</title>
    <link href="/2020/07/07/algorithm/BinarySearchTree/"/>
    <url>/2020/07/07/algorithm/BinarySearchTree/</url>
    
    <content type="html"><![CDATA[/** * 二叉搜索树 * 每个节点都有数据，另外含有两个指针，指向其他节点 * 特点：节点顺序基于节点值的大小，所有左节点的值都小于右节点的值 */var node = {    value: 124,    left: null,    right: null};function BinarySearchTree() {    this._root = null}BinarySearchTree.prototype = {    constructor: BinarySearchTree,    add: function (value) {        var node = {            value: value,            left: null,            right: null        },        current;        if (this._root === null) {            this._root = node;        } else {            current = this._root            while (true) {                if(value < current.value) {                    if (current.left === null) {                        current.left = node                        break;                    } else {                        current = current.left                    }                } else if (value >  current.right) {                    if (current.right === null) {                        current.right = node                        break                    } else {                        current = current.right                    }                } else {                    break                }            }        }    },    contains: function (value) {        var found = false,            current = this._root;        while (!found && current) {            if (value < current.value) {                current = current.right            } else if (value > current.value) {                current = current.left            } else {                found = true            }        }        return found        },    remove: function (value) {        var found = false,            parent = null,            current = this._root,            childCount,            replacement,            replacementParent;       // 定位要删除的节点 父节点要被记录              while(!found && current) {            if(value < current.value) {                parent = current                current = current.left            }else if (value > current.value) {                parent = current                current = current.right            } else {                found = true            }        }        if (found) {          // 计算节点数量            childCount = (current.left === null ? 0 : 1) + (current.right === null ? 0 : 1)            if(current === this._root) {                switch(childCount){                    case 0:                        this._root = null;                        break;                    case 1:                        this._root = current.right === null ? current.left : current.right                        break;                    case 2:                        //新的根节点是源根节点的做子节点                        //左子树的最右节点 直接前驱                        replacement = this._root.left                        while (replacement.right !== null) {                            replacementParent = replacement                            replacement = replacement.right                        }                        if(replacementParent !== null) {                            replacementParent.right = replacement.left                            replacement.right = this._root.right                            replacement.left = this._root.left                        }                        this._root = replacement                }            } else {                switch(childCount){                    case 0:                        if(current.value > parent.value) {                            parent.left = null;                        } else {                            parent.right = null                        }                        break;                    case 1:                        if(current.value > parent.value) {                        parent.left = current.left ? current.left.value : current.right.value                    } else {                        parent.right = current.left ? current.left.value : current.right.value                    }                    case 2:                      //TODO                        replacement = current.left                        replacementParent = current                        while (replacement.right !== null) {                            replacementParent = replacement                            replacement = replacement.right                        }                        replacementParent = replacement.left                         replacementParent.right = current.right                        replacementParent.left = current.left                        if (parent.value > replacement.value) {                            parent.left = replacement                        } else {                            parent.right = replacement                        }                }            }        }    },    size: function () {        var length = 0;        this.traverse(function(node){            length++;        })        return length    },    traverse: function (process) {        // 辅助函数遍历节点        function inOrder(node) {            if(node.left !== null) {                inOrder(node.left)            }            // call 使用指定的this 和单独给出的一个或多个参数调用一个函数，再次此处调用process            process.call(this, node);            if (node.right !== null) {                inOrder(node.right)            }        }        inOrder(this._root)    },    toArray: function () {        var result = [];        this.traverse(function(node){            result.push(node.value)        })        return result    },    toString: function () {        return this.toArray().toString();    },}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/BubbleSort</title>
    <link href="/2020/07/07/algorithm/BubbleSort/"/>
    <url>/2020/07/07/algorithm/BubbleSort/</url>
    
    <content type="html"><![CDATA[/** * 冒泡排序 * 比较前两个元素 -> 如果第一个元素应该排在第二个后面，则两者交换 -> 比较第二个与第三个元素  * 如果第二个元素应该在第三个后面，两者交换 -> 重复以上过程知道末尾 * 时间复杂度 平均复杂度O(n*n), 最好情况O(n), 最差情况(n*n) * 空间复杂度 O(1) * 稳定性 稳定 */function swap(items, firstIndex, secondIndex) {    var temp = items[firstIndex];    items[firstIndex] = items[secondIndex]    items[secondIndex] = temp}/** * 外层循环负责遍历，内层循环负责数组的元素比较 *  */function bubbleSort(items) {    var len = items.length,            i,            j,            stop;    for (i = 0; i < len; i++) {        var done = true        for(j = 0, stop = len-i-1; j < stop; j++) {            if(items[j] < item[j+1]) {                swap(items, j, j+1)                done = false            }        }        if (done) {            break;        }    }    return items}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/base64</title>
    <link href="/2020/07/07/algorithm/base64/"/>
    <url>/2020/07/07/algorithm/base64/</url>
    
    <content type="html"><![CDATA[function generateArray(length, arr = []) {  let randomNum = Math.floor((Math.random()*30)+2);  if(arr.indexOf(randomNum) === -1) {    arr.push(randomNum);  }  return arr.length < length ? generateArray(length, arr) : arr ;}function toFlat(arr, newArr = []) {  for (let key in arr) {    console.log(arr[key])    typeof arr[key] === 'number' ? newArr.push(arr[key]) : toFlat(arr[key], newArr);  }  return Array.from(new Set(newArr)).sort((a, b) =>{ return a - b});}// class LazyMan {//   constructor(name) {//     this.name = name//     console.log(`Hi I am ${name}`)//   }//   sleep(time) {//     setTimeout(() => {//       console.log(`等待了${time}`)//     }, time)//   }//   eat(some) {//     console.log(`I am eating ${some}`)//   }// }function LazyMan(name) {  if(! (this instanceof  LazyMan)) {    return  new LazyMan(name)  }  this.taskList = [];  this.next();  console.log(`Hi I am ${name}`);}LazyMan.prototype.sleep = function(time) {  let that = this  that.taskList.push({    delayTime: time * 1000,    callback() {      console.log(`等待了${time}s ...`)      that.next()    }  })  return this;}LazyMan.prototype.eat = function(food) {  let that = this  that.taskList.push({    delayTime: 0,    callback() {      console.log(`I am eating ${food}`)      that.next()    }  })  return that;}LazyMan.prototype.next = function() {  const taskList = this.taskList;  if ( taskList.length === 0 ) return;  const {delayTime, callback} = taskList[0]  setTimeout(() => {    callback && callback()    taskList.shift()    this.next()  },delayTime)}LazyMan('Tony').sleep(10).eat('lunch');function add() {  let args = [].slice.call(arguments);  let addArgs = args.length === 1 ? args[0] : args.reduce((pre, item) => {    return pre + item  })  function sumF() {    let addArgs2 = args.length === 1 ? args[0] : args.reduce((pre, item) => {      return pre + item    })    return addArgs += addArgs2  }  sumF.toString = function () {    return addArgs  }  return sumF;}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/linkedList</title>
    <link href="/2020/07/07/algorithm/linkedList/"/>
    <url>/2020/07/07/algorithm/linkedList/</url>
    
    <content type="html"><![CDATA[/** * 链表——一种基础数据结构 * 自身就是一个指针，指向头结点，相应的这个头节点又有个指针指向下一个节点，以此类推。 * 每个节点包含两块区域，数据区域包含该位置的值，另一个区域包含一个指针指向下一个节点 */function LinkList() {    this._length = 0;  // 长度属性    this._head = null; // 链表指向的第一个元素，一开始的链表为空}LinkList.prototype = {    add: function(data) {        var node = {            data: data,            next: null        },        current;        if (this._head === null) {            this._head = node        } else {            current = this._head;            while (current.next) {                current = current.next            }            current.next = node        }        this._length++    },    item: function(index) {        if (index > -1 && index < this._length) {            var current = this._head,            i = 0;            while (i++ < index) {                current = current.next;            }            return current.data;        } else {            return null;        }    },    remove: function(index) {        if (index > -1 && index < this._length) {            var current = this._head,                previous,                i = 0;            if (index === 0) {                this._head = current.next            } else {                // 找到正确的位置进行删除                while (i++ < index) {                    previous = current;                    current = current.next                }                previous.next = current.next            }            this._length--;            return current.data;        } else {            return null;        }    }}// 使用var list = new LinkedList();list.add('red')list.add('orange')list.add('yellow')function showStudent(ssn) {    var student = db.get(ssn);    if(student !== null) {        document.querySelector(`#{elementId}`).innerHTML = `${student.ssn}, ${student.firstname}, ${student.lastname}`;    } else {        throw  new Error('student is not found')    }}var find = curry(function (db, id) {    var obj = bd.get(id);    if(obj === null) {        throw new Error('Object not found');    }    return obj;})var csv = (student) {    return `${student.ssn}, ${student.firstname}, ${student.lastname}`;}var append = curry(function (elementId, info) {    document.querySelector(elementId).innerHTML = info;})var showStudent = run(append('#student-info'), csv, find(db));class Person {    constructor(firstname, lastname, ssn) {        this._firstname = firstname;        this._lastname = lastname;        this._ssn = ssn;        this._address = null;        this._birthYear = null;    }    get ssn() {        return this._ssn;    }    get firstname() {        return this._firstname;    }    get address() {        return this._address;    }    get birthYear() {        return this._birthYear;    }    set address(addr) {        this._address = addr;    }    toString() {        return `Person(${this._firstname}, ${this._lastname})`    }}class Student extends Person {    constructor(firtname, lastname, ssn, school) {        super(firtname, lastname, ssn);        this._school = school    }    get school() {        return this._school;    }}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/throttle</title>
    <link href="/2020/07/07/algorithm/throttle/"/>
    <url>/2020/07/07/algorithm/throttle/</url>
    
    <content type="html"><![CDATA[<p>##节流函数 throttle<br>###方案一</p><pre><code class="hljs plain">function throttle(fn, time) &#123;    let previous &#x3D; 0    return function(...args) &#123;        const temp &#x3D; +new Date();        if(temp - previous &gt; time) &#123;            previous &#x3D; temp            fn.apply(this, args);        &#125;       &#125;&#125;</code></pre><h4 id="防抖函数-debounce"><a href="#防抖函数-debounce" class="headerlink" title="防抖函数 debounce"></a>防抖函数 debounce</h4><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><pre><code>function debounce(fn, time){    let timer = null;    return function(...args) {        if(!timer) {            timer = setTimeout(() =&gt; {                fn.call(this, args)            }, time)           }        clearTimeout(timer)    }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>prototype/this</title>
    <link href="/2020/07/07/prototype/this/"/>
    <url>/2020/07/07/prototype/this/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http/http</title>
    <link href="/2020/07/07/http/http/"/>
    <url>/2020/07/07/http/http/</url>
    
    <content type="html"><![CDATA[<h2 id="http-简介"><a href="#http-简介" class="headerlink" title="http 简介"></a>http 简介</h2><p>http 超文本传输协议，主要规定浏览器和服务器相互通信规则，它是基于TCP/IP通信协议来进行传递数据<br>浏览器发起一http请求， 首先建立TCP连接  也就是常说的三次握手， 接下来发起Http请求<br>一个http请求主要包括 请求行 请求头 请求正文<br>请求行：请求地址、请求的方法（get， post、put、delete）、请求状态<br>2** 成功<br>#excerpt_link: Read More…<br>3** 重定向<br>    301 永久重定向<br>    302 临时重定向<br>    304 not modify<br>4** 客户端错误<br>    400 Bad request 请求中有语法错误<br>    401 Unauthorize 未被授权<br>    403 forbidden<br>    404 Not found<br>5** 服务端错误<br>    500<br>    503 service unavailable<br>请求头<br> Accept<br> host<br> UserAgent<br> cookie （key value domin expires size httponly）4k 最多可以有20个 默认到浏览器关闭<br> connection keep-alive<br>请求体<br>http 响应请求<br> 响应行<br> 响应体<br>  cache-control<br>  content-type<br>  status<br>  expires<br>  date<br>  Last-Modified<br>结束<br>断开 TCP 连接 四次挥手</p><h2 id="https-http-ssl"><a href="#https-http-ssl" class="headerlink" title="https = http + ssl"></a>https = http + ssl</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>prototype/prototype</title>
    <link href="/2020/07/07/prototype/prototype/"/>
    <url>/2020/07/07/prototype/prototype/</url>
    
    <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><hr><p><strong>constructor</strong> 返回实例对象构造函数的引用，此值是对函数本身的引用</p><pre>function Person (name) {    this.name = name;}var p = new Person(name);p.constructor === Person</pre><p>构造函数本身就是函数，不过为了规范都会首字母大写， 主要<code>区别</code>在于使用 <em>new</em> 生成的实例函数就是构造函数，直接调用的就是普通函数 </p><h3 id="constructor-是只读的吗？"><a href="#constructor-是只读的吗？" class="headerlink" title="constructor 是只读的吗？"></a>constructor 是只读的吗？</h3><p>对引用类型来是可以修改的，对基本数据类型是 只读的</p><pre>function Parent() {    this.name = 'xiaoming';    this.age = '18';}Parent.prototype = {    method: funtion () {}}function Children() {}Children.prototype = new Parent();Children.prototype.foo = 'Hello world'//此时constructor 指向 ObjectChildren.prototype.constructor === Object //true//修正constructorChildren.prototype.constructor = Children</pre><h3 id="new-到底是如果实现的呢"><a href="#new-到底是如果实现的呢" class="headerlink" title="new 到底是如果实现的呢"></a>new 到底是如果实现的呢</h3><pre>function create () {    // 创建一个空对象    var obj = new Object(),    //2. 获得构造函数，同时删除arguments 里的第一个参数    Con = [].shift.call(arguments);    //3. 链接到原型，obj可以访问到构造函数的属性    Object.setPrototypeOf(obj, Con.prototype)    //4.绑定this实现继承，让其可以访问构造函数的属性    var result = Con.apply(obj, arguments)    //优先返回构造函数的对象    return result instanceof Object ? result : obj}</pre><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><p>每个构造函数对象拥有一个<strong>原型对象</strong>，对象以原型为模板，从原型继承方法和属性，这些属性和方法定义在构造器函数的 <strong>prototype</strong> 属性上，而非本身</p><h2 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a>_<em>proto_</em></h2><p>构造函数的 prototype 属性有个 _<em>proto__属性，这是一个访问器属性（即getter 函数和 setter函数），通过他可以访问到对象内部的 [[Prototype]](一个对象或null)<br>##<br><em>_prototype</em></em> 属性在es6后才被标准化，获取或者设置可以用</p><pre>    Object.setPrototypeOf()    Object.getPrototypeOf()</pre><p>##原型链<br>每个对象拥有原型对象，通过<strong>proto</strong>指针指向该对象的原型，并从中集成方法和属性， 同时原型对象也可能拥有原型，这样一层一层，最终会指向null；这种关系被称作原型链</p><h2 id="实现-instanceOf"><a href="#实现-instanceOf" class="headerlink" title="实现 instanceOf"></a>实现 instanceOf</h2><pre>function _instanceOf (instance, object){    // 获取对象的原型    const prototype = object.prototype;    //获取要检查对象的原型    let proto = instance.__proto__;    //遍历要检查的原型链，until the end of instance    while (__proto__ !== null) {        if (__proto__ === prototype) {            return true;        }        proto =  proto.__proto__;    }    return false;}</pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise 详解</title>
    <link href="/2020/07/07/promise/1/"/>
    <url>/2020/07/07/promise/1/</url>
    
    <content type="html"><![CDATA[<p>new Promise时， 需要传递一个 executor 执行器， 执行器立即执行</p><a id="more"></a><p>/**</p><ul><li><ol><li>new Promise时， 需要传递一个 executor 执行器， 执行器立即执行</li></ol></li><li><ol start="2"><li>executor 接受两个参数 分别是 resolve 和 reject</li></ol></li><li><ol start="3"><li>promise 只能从 pending 到 rejected， 或者 从 pending 到 resolved</li></ol></li><li><ol start="4"><li>promise 的状态一旦确认， 就不会再改变</li></ol></li><li><ol start="5"><li>promise 都有 then 方法， then方法接收两个参数， </li></ol></li><li>分别是 promise 成功回调的 onFulfilled 和 失败回调的 onRejected</li><li><ol start="6"><li>如果调用 then 时，promise已经成功，则执行 onFulfilled 并将 promise的值作为参数传进去</li></ol></li><li>如果promise已经失败， 那么执行 onRejected 并将 promise失败的原因作为参数传递进去</li><li>如果promise是pending状态，则把 onFulfilled 和 onRejected 函数存起来， 等到状态确定后，</li><li>再按照相应的对象执行（发布-订阅模式）</li><li><ol start="7"><li>onFulfilled 和 onRejected 的参数可以缺省</li></ol></li><li><ol start="8"><li>promise 可以 then 多次，promise的then 返回一个promise</li></ol></li><li><ol start="9"><li>如果then返回的是一个结果， 那么可以把这个结果作为参数，传递下一个then 的 onFulfilled成功的回调</li></ol></li><li><ol start="10"><li>如果then 返回的是一个异常， 那么可以把这个异常作为参数， 传递给下一个then 的 onRejected 失败回调</li></ol></li><li><ol start="11"><li>如果 then 返回的是一个promise, 那么需要等这个promise 那么等到这个promise 执行完</li></ol></li><li>promise执行成功就走下一个then成功， promise执行失败就走下一个then的失败</li><li>/</li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">"pending"</span>;<span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">"fulfilled"</span>;<span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">'rejected'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">excutor</span>) </span>&#123;  <span class="hljs-keyword">let</span> that = <span class="hljs-keyword">this</span>; <span class="hljs-comment">//缓存当前promise 实例对象</span>  that.status = PENDING; <span class="hljs-comment">// 初始状态</span>  that.value = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// fulfilled状态时 返回的信息</span>  that.reason = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// rejected状态时 拒绝的原因</span>  that.onFulfilledCallbacks = []; <span class="hljs-comment">//存储fulfilled 状态对应的onFulfilled函数</span>  that.onRejectedCallbacks = []; <span class="hljs-comment">//存储rejected 状态对应的onRejected 函数</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resovle</span> (<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-comment">//value 成功态时接受的终值</span>    <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;      <span class="hljs-keyword">return</span> value.then(resovle, reject)    &#125;    <span class="hljs-comment">//实践中要确保 onFulfilled 和 onRejected方法异步执行，</span>    <span class="hljs-comment">//且应该在then 方法调用的时候那一轮事件循环的执行栈执行结束之后</span>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-comment">// 调用resovle 回调对应的onFulfilled函数</span>      <span class="hljs-keyword">if</span> (that.status === PENDING) &#123;        <span class="hljs-comment">// 只能由pending状态 =》 fulfilled 状态（避免多次调用resovle reject）</span>        that.status = FULFILLED;        that.value = value;        that.onFulfilledCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;          callback(that.value)        &#125;);      &#125;    &#125;)  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-comment">// 调用reject 回调对应onRejected 函数</span>        <span class="hljs-keyword">if</span> (that.status === PENDING) &#123;          <span class="hljs-comment">// 只能由 pending =》 rejected （避免多次调用resovle reject）</span>          that.status = REJECTED;          that.reason = reason;          that.onRejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;            callback(that.reason)          &#125;)        &#125;    &#125;)  &#125;  <span class="hljs-comment">//捕获在excutor执行期炮数的异常</span>  <span class="hljs-keyword">try</span> &#123;    excutor(resovle, reject)  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    reject(e)  &#125;&#125;</code></pre><p>Promise.prototype.then = function(onFulfilled, onRejected) {<br>  const that = this;<br>  let newPromise;<br>  onFulfilled =<br>    typeof onFulfilled === “function” ? onFulfilled : value =&gt; value;<br>  onRejected =<br>   typeof onRejected === “function” ? onRejected : reason =&gt; {<br>     throw reason<br>   }</p><p>   if(that.status === FULFILLED) {<br>     return newPromise = new Promise((resovle, reject) =&gt; {<br>       setTimeout(() =&gt; {<br>         try {<br>           let x = onFulfilled(that.value)<br>           resovlePromise(newPromise, x, resovle, reject);<br>         } catch (error) {<br>           reject(error)<br>         }<br>       })<br>     })<br>   }</p><p>   if(that.status === REJECTED) {<br>     return newPromise = new Promise(() =&gt; {<br>       setTimeout(() =&gt; {<br>         try {<br>           let x = onRejected(that.reason)<br>           resovlePromise(newPromise, x, resovle, reject)<br>         } catch (error) {<br>           reject(error)<br>         }<br>       })<br>     })<br>   }</p><p>   if(that.status === PENDING) {<br>     that.onFulfilledCallbacks.push(() =&gt; {<br>        setTimeout(() =&gt; {<br>          try {<br>            let x = onFulfilled(that.value)<br>            resovlePromise(newPromise, x, resovle, reject)<br>          } catch (error) {<br>            reject(error)<br>          }<br>        })<br>     })</p><pre><code>that.onRejectedCallbacks.push(() =&gt;{  setTimeout(() =&gt; {    try {      let x = onRejected(that.reason)      resovlePromise(newPromise, x, resovle, reject)    } catch (error) {      reject(error)    }  })})</code></pre><p>  }</p><p>}</p><p>function resovlePromise (newPromise, x, resolve, reject) {<br>  let that = this;<br>  if(newPromise === x) {<br>    reject(new TypeError(‘Chaining cycle’));<br>  }<br>  if(x &amp; typeof x === ‘object’ || typeof x === ‘function’) {<br>    let used;<br>    try {<br>      let then = x.then;<br>      if(typeof then === ‘function’) {<br>        then.call(x, (y) =&gt; {<br>          if(used) return;<br>          used === true;<br>          resovlePromise(newPromise, y, resolve, reject);<br>        }, (reason) =&gt; {<br>          if(used) return;<br>          used === true;<br>          reject(reason);<br>        })<br>      }else {<br>        if(used) return;<br>        used = true;<br>        resolve(x);<br>      }<br>    } catch (error) {<br>      if(used) return;<br>      used = true;<br>      reject(error);<br>    }<br>  }else{<br>    resolve(x);<br>  }<br>}</p><p>// promise.finally<br>// 不管成功 or 失败 最终都会走到finally 还可以继续 then 且可以把值原封不动的传给后面的then<br>Promise.prototype.finally = function (callback) {<br>  return this.then((value) =&gt; {<br>    return Promise.resolve(callback()).then(() =&gt; {<br>      return value<br>    })<br>  }, (err) =&gt; {<br>    return Promise.resolve(callback().then(() =&gt; {<br>      throw err<br>    }))<br>  })<br>}</p><p>//promise.all（promises） 返回一个promise对象<br>/**</p><ul><li><ol><li>如果传入的是一个空的可迭代对象，那么此promise对象回调完成（resolve），</li></ol></li><li><p>只有这种情况是同步执行的，其他的都是返回一个异步完成</p></li><li><ol start="2"><li>如果传入参数不包含任何一个promise， 则返回一个异步完成</li></ol></li><li><ol start="3"><li>promises 所有的promise都完成时，或参数中不包含promise时 回调完成</li></ol></li><li><ol start="4"><li>如果一个 promise 失败，那么promise.all 返回的promise对象失败</li></ol></li><li><ol start="5"><li>在任何情况下，promises返回的promise的完成状态结果都是一个数组</li></ol></li><li><p>/</p><p>Promise.prototype.all = function (promises) {<br> return new Promise((resolve, rejected) =&gt; {<br>  let index = 0;<br>  let result = [];<br>  if (promises.length === 0) {</p><pre><code>resolve(result)</code></pre><p>  } else {</p><pre><code>function processValue (idx, data) {  result[i] = data;  if (++index === promises.length) {    resolve(result)  }}for (let i = 0; i &lt; promises.length; i++) {  //promises[i]可能是个普通值  Promise.resolve(promises[i]).then((data) =&gt; {    processValue(i, data)  }, (err) =&gt; {    rejected(err);    return;  })}</code></pre><p>  }<br> })<br>}</p></li></ul><p> //Promise.race()<br> /**</p><ul><li>返回一个promise函数，他将与第一个传递的promise相同的方式被完成，他可以是完成也可以是失败，</li><li>取决于第一个完成的方式是两个中的哪一个</li><li>如果传递的是一个空数组，那么primise将处于永远等待</li><li>如果迭代中包含一个或多个 非promise/resolve/reject的promise，那么promise.race将解析为迭代中找到的第一个值</li><li>/<br>Promise.prototype.race = function(promises) {<br>return new Promise((resovle, reject) =&gt; {<br> if(promises.length === 0) {<br>   return;<br> }else {<br>   for (let i = 0; i &lt; promises.length; i++) {<pre><code>Promise.resolve(promises[i]).then((data)=&gt; {  resolve(data);  return;}, (err) =&gt; {  reject(err);  return;})</code></pre>   }<br> }<br>})<br>}</li></ul><p>//Promise.allSettled<br>/**</p><ul><li><p>将一组promise实例作为参数，包装成一个新的promise实例，只有等到所有的promise都执行完成后</p></li><li><p>不管是fulfilled 或是 rejected 包装实例才会结束</p></li><li><p>/</p><p>//Promise.any<br>/**</p></li><li><p>将一组promise实例作为参数，包装成一个新的promise实例，实例参数只要有一个promise是resolve状态</p></li><li><p>包装的实例则返回resolve状态，如果实例参数都返回rejected状态，实例才返回 rejected</p></li><li><p>/</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/Function/compose</title>
    <link href="/2020/07/07/algorithm/Function/compose/"/>
    <url>/2020/07/07/algorithm/Function/compose/</url>
    
    <content type="html"><![CDATA[/** * 函数的组合 */let toUpperCase = function (str) {    return str.toUpperCase(str);}let hello = function(name) {    return `hi, {name}!`;}let sayHello = function() {    return hello(toUpperCase('Tom'));}/** * 我们可以看到 hello 函数使用了 toUpperCase的返回值 类似于 * sayHello = f(g(x)), 这时我们可以写一个compose 函数 将这个函数做为参数*/function _compose(f, g) {    return function (x) {        return f(g(x));    }}/** * 如果 compose(f, g, h, i)? * 难道要写成 compose(f, compose(g, compose(h, i))? */function compose() {    let length = arguments.length;    let args = arguments;    return function () {        let start = length -1;        let result = args.apply(this, arguments);        while (start--) args[start].apply(this, result)        return result;    }}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/Array/index</title>
    <link href="/2020/07/07/algorithm/Array/index/"/>
    <url>/2020/07/07/algorithm/Array/index/</url>
    
    <content type="html"><![CDATA[/** 数组的扁平化* 已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];* 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组* */Array.prototype.flat = function (arr, result) {  result  arr.forEach((item) => {    Array.isArray(item) ? arguments.callee(item) : item.push(newArr)  })  return newArr}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/Function/curry</title>
    <link href="/2020/07/07/algorithm/Function/curry/"/>
    <url>/2020/07/07/algorithm/Function/curry/</url>
    
    <content type="html"><![CDATA[/** * @name curry * @version 1.0 * @description 函数的柯里化  * @param fn * @param num * @example curry(add, 1, 2)*/function _curry(fn) {    const args = [].slice.apply(arguments, 1);    return function () {        return fn.apply(this, args.concat(...arguments))    }}/** * @name curry * @version 1.1 * @param fn * @description currying is a technique of translating an evaluation of a function  * that takes multiple arguments (or tuple arguments) into evaluating a sequence  * functions, each with a single function; * @param length fn的参数个数 * @example curry(add(1, 2)) */ function curry(fn, length) {    // 判断要curry的函数的参数个数      length = length || fn.length;    let slice = Array.prototype.slice;    return function () {        if(arguments.length < length) {            const args = [fn].concat(slice.apply(this, arguments))            return curry(_curry.apply(this, args), length - arguments.length);        } else {            return fn.apply(this, arguments)        }            } }]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Apollo-Server</title>
    <link href="/2020/07/06/Apollo-Server/index/"/>
    <url>/2020/07/06/Apollo-Server/index/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Apollo-Server-是什么"><a href="#Apollo-Server-是什么" class="headerlink" title="Apollo Server 是什么"></a>Apollo Server 是什么</h4><p> <a href="http://www.baidu.com" target="_blank" rel="noopener">Apollo Server</a> 是一种符合规范的开源 GraphQL服务器，能与任何GraphQL客户端（包括Apollo Client）兼容。并且可以使用任何来源数据去构建生产预发环境、生成 GraphQL API 文档的最佳方法。</p><p> 您可以将<strong>Apollo Server</strong>用作：</p><ul><li><p>独立的GraphQL服务器，包括在serverless环境中</p></li><li><p>现有应用的Node.js中间件的扩展（例如Express或Fastify）的附件</p></li><li><p>Federated data graph的网关</p><p><strong>Apollo Server</strong> 提供：</p></li><li><p>简单易用的设置，因此您的客户端开发人员可以快速开始获取数据</p></li><li><p>渐进式采用，使您可以根据需要添加功能</p></li><li><p>可以兼容任何数据源、构建工具、GraphQL客户端</p></li><li><p>生产就绪，使您能够更快地发布功能</p></li></ul><h3 id="开始使用-Apollo-Server"><a href="#开始使用-Apollo-Server" class="headerlink" title="开始使用 Apollo Server"></a>开始使用 Apollo Server</h3><blockquote><p>本教程主要引导你安装和配置Apollo Server。如果您刚刚开始使用GraphQL 或者 Apollo平台，我们推荐您先完成<a href="https://www.apollographql.com/docs/tutorial/introduction" target="_blank" rel="noopener">full-stack-tutorial</a>。</p></blockquote><p>本教程可以帮助您：</p><ul><li>对GraphQL原理有基本了解</li><li>定义一个代表数据集结构的GraphQL <strong>schema</strong></li><li>运行Apollo Server实例，使您可以依照你的schema执行查询</li></ul><p>本教程假定您熟悉命令行和JavaScript，并且已安装了最新版本的Node.js（8+）。</p><h4 id="第一步：创建一个新的项目"><a href="#第一步：创建一个新的项目" class="headerlink" title="第一步：创建一个新的项目"></a>第一步：创建一个新的项目</h4><p>1.在您首选的开发目录中，为新项目创建目录并 <code>cd</code> 进入该目录：</p><pre><code class="hljs plain">mkdir graphql-server-examplecd graphql-server-example</code></pre><p>2.使用<code>npm</code>（或您喜欢的另一个包管理器，例如Yarn）初始化一个新的Node.js项目：</p><pre><code class="hljs plain">npm init --yes</code></pre><p>您的项目目录现在包含一个<code>package.json</code>文件。</p><h4 id="第二步：安装依赖项"><a href="#第二步：安装依赖项" class="headerlink" title="第二步：安装依赖项"></a>第二步：安装依赖项</h4><p>运行Apollo Server的应用程序需要两个顶级依赖项：</p><ul><li><a href="https://www.npmjs.com/package/apollo-server" target="_blank" rel="noopener">apollo-server</a> 是Apollo Server本身的核心库，可帮助您定义数据的形状以及如何获取数据。</li><li><a href="https://www.npmjs.com/package/graphql" target="_blank" rel="noopener">graphql</a> 是用于构建GraphQL Schema并对其执行查询的库。</li></ul><p>运行以下命令以安装这两个依赖项并将它们保存在项目的<code>node_modules</code>目录中：</p><pre><code class="hljs plain">npm install apollo-server graphql</code></pre><p>还要<code>index.js</code>在项目的根目录中创建一个空文件：</p><pre><code class="hljs plain">touch index.js</code></pre><p>为简单起见，<code>index.js</code>将包含此示例应用程序的所有代码。</p><h4 id="第三步：定义您的GraphQL-Schema"><a href="#第三步：定义您的GraphQL-Schema" class="headerlink" title="第三步：定义您的GraphQL Schema"></a>第三步：定义您的GraphQL Schema</h4><p>每个GraphQL服务器（包括Apollo服务器）都使用一种<strong>Schema</strong>来定义客户端可以查询的数据结构。在此示例中，我们将创建一个服务器，用于按书名和作者查询书籍集合。</p><p><code>index.js</code>在您喜欢的编辑器中打开并将以下内容粘贴到其中：</p><pre><code class="hljs plain">const &#123; ApolloServer, gql &#125; &#x3D; require(&#39;apollo-server&#39;);&#x2F;&#x2F; A schema is a collection of type definitions (hence &quot;typeDefs&quot;)&#x2F;&#x2F; that together define the &quot;shape&quot; of queries that are executed against&#x2F;&#x2F; your data.const typeDefs &#x3D; gql&#96;  # Comments in GraphQL strings (such as this one) start with the hash (#) symbol.  # This &quot;Book&quot; type defines the queryable fields for every book in our data source.  type Book &#123;    title: String    author: String  &#125;  # The &quot;Query&quot; type is special: it lists all of the available queries that  # clients can execute, along with the return type for each. In this  # case, the &quot;books&quot; query returns an array of zero or more Books (defined above).  type Query &#123;    books: [Book]  &#125;&#96;;</code></pre><p>此代码段定义了一个简单有效的GraphQL Schema。客户将能够执行名为的查询books，并且我们的服务器将返回零个或多个Books 的数组。</p><h4 id="第四步：定义您的数据集"><a href="#第四步：定义您的数据集" class="headerlink" title="第四步：定义您的数据集"></a>第四步：定义您的数据集</h4><p>现在我们已经定义了数据的结构，我们可以定义数据本身了。Apollo服务器可以从您连接到的任何源（包括数据库，REST API，静态对象存储服务，甚至另一个GraphQL服务器）中获取数据。出于本教程的目的，我们将对一些示例数据进行硬编码。</p><p>将以下内容添加到的底部<code>index.js</code>：</p><pre><code class="hljs plain">const books &#x3D; [  &#123;    title: &#39;Harry Potter and the Chamber of Secrets&#39;,    author: &#39;J.K. Rowling&#39;,  &#125;,  &#123;    title: &#39;Jurassic Park&#39;,    author: &#39;Michael Crichton&#39;,  &#125;,];</code></pre><p>此代码段定义了客户端可以查询的简单数据集。注意，数组中的两个对象均与Book我们在架构中定义的类型的结构匹配。</p><h4 id="第五步：定义解析器"><a href="#第五步：定义解析器" class="headerlink" title="第五步：定义解析器"></a>第五步：定义解析器</h4><p>我们已经定义了数据集，但是Apollo Server不知道在执行查询时应该如何使用该数据集。为了解决这个问题，我们创建了一个 resolver。</p><p>让解析器告诉Apollo Server 如何获取与特定类型关联的数据。因为我们的Book数组是硬编码的，所以相应的解析器很简单。</p><p>将以下内容添加到的底部<code>index.js</code>：</p><pre><code class="hljs plain">&#x2F;&#x2F; Resolvers define the technique for fetching the types defined in the&#x2F;&#x2F; schema. This resolver retrieves books from the &quot;books&quot; array above.const resolvers &#x3D; &#123;  Query: &#123;    books: () &#x3D;&gt; books,  &#125;,&#125;;</code></pre><h4 id="第六步：创建ApolloServer实例"><a href="#第六步：创建ApolloServer实例" class="headerlink" title="第六步：创建ApolloServer实例"></a>第六步：创建ApolloServer实例</h4><p>我们已经定义了架构，数据集和解析器。现在，我们只需要在初始化时向Apollo Server提供此信息即可。</p><p>将以下内容添加到的底部index.js：</p><pre><code class="hljs plain">&#x2F;&#x2F; The ApolloServer constructor requires two parameters: your schema&#x2F;&#x2F; definition and your set of resolvers.const server &#x3D; new ApolloServer(&#123; typeDefs, resolvers &#125;);&#x2F;&#x2F; The &#96;listen&#96; method launches a web server.server.listen().then((&#123; url &#125;) &#x3D;&gt; &#123;  console.log(&#96;🚀  Server ready at $&#123;url&#125;&#96;);&#125;);</code></pre><h4 id="第七步：启动服务器"><a href="#第七步：启动服务器" class="headerlink" title="第七步：启动服务器"></a>第七步：启动服务器</h4><p>我们已经准备好启动服务器！从项目的根目录运行以下命令：</p><pre><code class="hljs plain">node index.js</code></pre><p>您应该看到以下输出：</p><pre>🚀 Server ready at http://localhost:4000/</pre><h4 id="第八步：执行第一个查询"><a href="#第八步：执行第一个查询" class="headerlink" title="第八步：执行第一个查询"></a>第八步：执行第一个查询</h4><p>现在，我们可以在服务器上执行GraphQL查询。要执行查询时，我们将使用一个名为GraphQL Playground的工具。</p><div class="note note-info">            <p>注意：如果将服务器部署到NODE_ENV设置为的环境，则production默认情况下将禁用GraphQL Playground和自省功能。要启用它们，您需要显式设置，playground: true并 introspection: true在的Constructor 选项ApolloServer内。</p>          </div><p>在服务器仍在运行的情况下，<a href="http://localhost:4000在浏览器中访问以打开GraphQL">http://localhost:4000在浏览器中访问以打开GraphQL</a> Playground。（在开发中运行GraphQL Playground时，Apollo Server会自动托管它。</p><p>GraphQL Playground UI包括</p><ul><li>用于编写查询的文本区域（左侧）</li><li>用于执行查询的“播放”按钮（中间的三角形按钮）</li><li>用于查看查询结果的文本区域（右侧）</li><li>查看架构检查和生成的文档的视图（通过右侧的选项卡）</li></ul><p>我们的服务器支持一个名为的查询<code>books</code>。让我们执行它！</p><p>这是用于执行查询的GraphQL 查询字符串<code>books</code>。</p><pre>{  books {    title    author  }}</pre><p>将此字符串粘贴到左侧文本区域，然后单击“播放”按钮。结果（来自我们的硬编码数据集）显示在右侧：</p><p>GraphQL的最重要概念之一是我们可以选择仅查询 所需的字段。<code>author</code>从查询字符串中删除并再次执行。响应更新为仅包括<code>title</code>每本书的字段！</p><h3 id="定义一个Schema"><a href="#定义一个Schema" class="headerlink" title="定义一个Schema"></a>定义一个Schema</h3><h4 id="schema基础"><a href="#schema基础" class="headerlink" title="schema基础"></a>schema基础</h4><p>GraphQL服务器使用<strong>Schema</strong>描述数据图的形状。Schema用来源于后端的数据字段来定义不同层级类型层次，schema还精确指定了能针对您的数据图、可用于客户端执行的query和mutation。<br>本文旨在介绍schema的基本构成以及如何为您的GraphQL服务器创建一个Schema。</p><h5 id="schema定义语言"><a href="#schema定义语言" class="headerlink" title="schema定义语言"></a>schema定义语言</h5><p>GraphQL规范包含一种人类可读的架构定义语言（或SDL），可用于定义Schema并将其存储为字符串</p><p>我们来定义两个对象类型：<code>Author</code> 和 <code>Book</code></p><pre>type Book {  title: String  author: Author}type Author {  name: String  books: [Book]}</pre><p>Schema 定义了类型的集合和类型的关系。在上面的例子中，每一个<code>Book</code>有一个<code>author</code>，每一个<code>Author</code>有<code>books</code>的列表。通过在整合的Schema中定义这些类型的关系，我们可以确保每一个客户端开发者可以准确查看可用数据，<br>并且通过单个优化查询请求该数据的特定子集</p><p>注意Schema并不关注数据的来源或者如何存储。它完全与实现无关。</p><h5 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h5><ul><li>标量类型</li><li>对象类型</li><li>Query 类型</li><li>Mutation 类型</li><li>输入类型<br>下面分别详细介绍这些内容。</li></ul><h6 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h6><p>标量类型类似于编程语言中的基本类型。他们总是解析具体的数据。</p><p>GraphQL的默认标量类型为：</p><ul><li><code>Int</code>：有符号的32位整数</li><li><code>Float</code>：带符号的双精度浮点值</li><li><code>String</code>：UTF-8字符序列</li><li><code>Boolean</code>：true或false</li><li><code>ID（序列化为String）</code>：唯一标识符，通常用于重新获取对象或用作缓存的键。尽管将其序列化为String，但<code>ID</code>并不旨在使其易于理解。</li></ul><p>这些原始类型涵盖了大多数用例。对于更特定的用例，您可以创建自定义标量类型。</p><h6 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h6><p>在GraphQL模式中定义的大多数类型都是对象类型。对象类型包含字段的集合，每个字段可以是标量类型或其他对象类型。</p><p>两种对象类型可以彼此包含为字段，就像前面的示例Schema中那样：</p><pre>type Book {  title: String  author: Author}type Author {  name: String  books: [Book]}</pre><h6 id="Query-类型"><a href="#Query-类型" class="headerlink" title="Query 类型"></a>Query 类型</h6><p>Query类型定义根据您的数据图执行查询的入口点。它类似于对象类型，但其名称始终为Query。</p><p>Query类型的每个字段定义不同入口点的名称和返回类型。Query我们的Schema类型可能类似于以下内容：</p><pre>type Query {  books: [Book]  authors: [Author]}</pre><p>这个查询类型定义了两个字段：<code>books</code> 和 <code>authors</code>。每个字段都返回一个列表<br>基于RestFul API，books 和 authors 很可能从不同的端点返回（eg： <code>/api/books</code> 和 <code>/api/authors</code>。而GraphQL的灵活性能保证通过一个请求返回这两个数据。</p><p><strong>构造一个query</strong><br>当你开始根据你的数据图来创建查询时，这些查询必须与你在Schema中定义好的结构相匹配。</p><p>基于我们例子中Schema，客户端执行下面的查询操作，将会返回所有的books和author 的列表</p><pre>query GetBooksAndAuthors {  books {    title  }  authors {    name  }}</pre><p>服务端会根据查询结构，将查询到的结果做如下返回</p><pre>{  "data": {    "books": [      {        "title": "Jurassic Park"      },      ...    ],    "authors": [      {        "name": "Michael Crichton"      },      ...    ]  }}</pre><p>尽管在某些情况下获取这两个单独的列表可能很有用，但是客户可能更喜欢获取一个图书列表，其中每本书的作者都包含在结果中。<br>因为我们的Schema的Book类型具有type的author字段Author，所以客户端可以改为这样构造其查询：</p><pre>query GetBooks {  books {    title    author {      name    }  }}</pre><p>再一次，我们的服务器将响应与查询结构匹配的结果：</p><pre>{  "data": {    "books": [      {        "title": "Jurassic Park",        "author": {          "name": "Michael Crichton"        }      },      ...    ]  }}</pre><h6 id="Mutation-类型"><a href="#Mutation-类型" class="headerlink" title="Mutation 类型"></a>Mutation 类型</h6><p>Mutation类型在结构和目的与Query类型类似。Query类型定义了读操作的入口点，而Mutation类型定义了写操作的入口点。</p><p>Mutation类型的每个字段定义不同入口点的标志和返回类型。Mutation我们的示例Schema的类型可能类似于以下内容：</p><pre>type Mutation {  addBook(title: String, author: String): Book}</pre><p>这个mutation类型定义了一个可用的mutation，<code>addBook</code>。这个mutation接收两个参数（title和author）并且返回一个新的<code>Book</code>对象。正如你所期望的，这个<code>Book</code>对象遵循我们在schema中定义的结构。</p><p><strong>构造一个mutation</strong><br>和query一样，mutations也应与我们的schema 定义的类型相匹配。下面的mutation 创建了一个新的<code>Book</code>而且请求已创建的对象的特定字段作为返回值。</p><pre>mutation CreateBook {  addBook(title: "Fox in Socks", author: "Dr. Seuss") {    title    author {      name    }  }}</pre><p>服务端将根据我们设计的mutation结构返回结果</p><pre>{  "data": {    "addBook": {      "title": "Fox in Socks",      "author": {        "name": "Dr. Seuss"      }    }  }}</pre><p>一个客户端请求可能包含多个需要执行的mutation。为了避免出现竞态，mutations的执行是线性的（根据列出的顺序）</p><p>学习更多关于mutations的设计</p><h6 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h6><p>输入类型是特殊的对象类型，它允许你传递一个对象作为参数进行query和mutation操作（与仅支持传标量类型相对）。输入类型可以帮助保持操作标识的整洁，就像在JavaScript函数中接受单个<code>options</code>对象比重复添加参数更干净一样。</p><p>看一下这个提交创建blog的mutation操作：</p><pre>type Mutation {  createPost(title: String, body: String, mediaUrls: [String]): Post}</pre><p>与接收三个参数相对，下面这个mutation只接受一个输入类型（包含这三个参数）。如果我们在将来决定增加一个参数会显得格外的方便，例如 <code>author</code></p><p>定义输入类型和对象类型很相似， 唯一不同就是我们需要使用 <code>input</code>关键字</p><pre>type Mutation {  createPost(post: PostAndMediaInput): Post}input PostAndMediaInput {  title: String  body: String  mediaUrls: [String]}</pre><p>输入类型不仅促进了PostAndMediaInput类型在我们Schema中的传递，而且提供了给字段增加注释空间，该描述可以自动的暴露给GraphQL可用工具。</p><pre>input PostAndMediaInput {  "A main title for the post"  title: String  "The text body of the post."  body: String  "A list of URLs to render in the post."  mediaUrls: [String]}</pre><p>当多个操作需要完全相同的数据集合时，输入类型有时会很有用，但是您应该谨慎地复用它们。操作最终可能会在其所需的参数之间产生分歧。</p><p><strong>不要对query和mutation使用相同</strong>的输入类型。在许多情况下，mutation所需的参数对于相应的query是可选的。</p><h5 id="Schema的扩大"><a href="#Schema的扩大" class="headerlink" title="Schema的扩大"></a>Schema的扩大</h5><p>随着你的组织成长与演变，你的数据图也会相应的成长。新的产品和特性会引入新的Schema类型和字段。为了追踪这段时间的变化，你应该用版本控制去维护你的定义的Schema。</p><p>大多数的Schema的增加是安全且向后兼容的。但是，发生的变化产生的删除和修改行为对于一个或更多已存在的应用可能是破坏性的改变。下面的schema改变会具有潜在的破坏性：</p><ul><li>删除一个类型或字段</li><li>重命名一个类型或字段</li><li>增加一个可为空字段</li><li>删除一个字段参数</li></ul><p>诸如Apollo Studio[<a href="https://studio.apollographql.com/]之类的图形管理工具可帮助您了解潜在的Schema更改是否会影响您的正在使用客户端。Studio还通过操作安全列表提供字段级性能指标，Schema历史记录跟踪和高级安全性。" target="_blank" rel="noopener">https://studio.apollographql.com/]之类的图形管理工具可帮助您了解潜在的Schema更改是否会影响您的正在使用客户端。Studio还通过操作安全列表提供字段级性能指标，Schema历史记录跟踪和高级安全性。</a></p><h5 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h5><p>GraphQL的Schema定义语言（SDL）支持启用markdown的文档字符串。这些可帮助数据图的使用者发现字段并学习如何使用它们。</p><p>以下代码段显示了如何同时使用单行字符串文字和多行块：</p><pre>"Description for the type"type MyObjectType {  """  Description for field  Supports **multi-line** description for your [API](http://example.com)!  """  myField: String!  otherField(    "Description for argument"    arg: Int  )}</pre><p>文档完善的schema可以提升开发者体验，因为GraphQL开发者工具（例如Apollo VS Code extension 和 GraphQL Playground）可以根据我们提供的描述自动填写字段名。而且 Apollo Studio在使用其指标报告和客户端感知功能时，会在字段使用情况和性能详细信息的旁边显示说明</p><h5 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h5><p>GraphQL规范是很灵活的而且不强制特定的命名规范。但是在组织中建立一个约定集合确保持续集成是很有用的。我们推荐如下：</p><ul><li>字段名 使用<code>camelCase</code>命名。大部分GraphQL客户端都使用 JavaScript, Java, Kotlin, or Swift，我们都推荐使用<code>camelCase</code>命名变量名</li><li>类型名 使用<code>PascalCase</code>命名。这与上述语言中定义类的方式匹配</li><li>枚举名 使用<code>PascalCase</code></li><li>枚举值 使用<code>ALL_CAPS</code>，因为它们类似于常量</li></ul><p>这些约定有助于确保大多数客户端不需要定义额外的逻辑即可转换服务器返回的结果</p><h5 id="query-驱动的Schema设计"><a href="#query-驱动的Schema设计" class="headerlink" title="query 驱动的Schema设计"></a>query 驱动的Schema设计</h5><p>当GraphQL schema的执行操作是依据客户端的需求而设计时，其功能最为强大。尽管您可以构造类型，使它们与后端数据存储的结构匹配，但您duck不必这样！单个对象类型的字段可以许多不同来源的数据所填充。<strong>根据数据的使用方式（而不是数据的存储方式）设计Schema</strong>。</p><p>如果您的数据存储区包含客户尚不需要的字段或关系，请从您的模式中将其忽略。向架构中添加新字段比删除某些客户端正在使用的现有字段更加容易和安全。</p><p><strong>query 驱动的Schema设计示例</strong><br>假设我们正在创建一个Web应用程序，其中列出了我们区域内的近期活动。我们希望该应用程序显示每个事件的名称，日期和位置，以及天气预报。</p><p>在这种情况下，我们希望Web应用程序能够执行具有类似于以下内容的结构的查询</p><pre>query EventList {  upcomingEvents {    name    date    location {      name      weather {        temperature        description      }    }  }}</pre><p>因为我们知道这是对我们的客户有帮助的数据结构，所以可以通知我们架构的结构：</p><pre>type Query {  upcomingEvents: [Event]}type Event {  name: String  date: String  location: Location}type Location {  name: String  weather: WeatherInfo}type WeatherInfo {  temperature: Float  description: String}</pre><p>如上所述，可以使用来自不同数据源（或多个数据源）的数据填充这些类型中的每一个。例如，该Event类型的name和date可能会填充有我们后端数据库中的数据，而该WeatherInfo类型的可能会填充有来自第三方Weather API的数据。</p><h5 id="设计mutation"><a href="#设计mutation" class="headerlink" title="设计mutation"></a>设计mutation</h5><p>在GraphQL中，建议每个突变的响应都包含该突变修改的数据。这使客户端无需发送后续查询即可获取最新的持久化数据。</p><p>一个模式，支持更新email的User会包括以下内容：</p><pre> type Mutation {   # This mutation takes id and email parameters and responds with a User   updateUserEmail(id: ID!, email: String!): User } type User {   id: ID!   name: String!   email: String! }</pre><p>然后，客户端可以针对具有以下结构的架构执行变异：</p><pre>mutation updateMyUser {  updateUserEmail(id: 1, email: "jane@example.com"){    id    name    email  }}</pre><p>GraphQL服务器执行更改并为用户存储新的电子邮件地址后，它将使用以下内容响应客户端：</p><pre>{  "data": {    "updateUserEmail": {      "id": "1",      "name": "Jane Doe",      "email": "jane@example.com"    }  }}</pre><p>虽然它不是强制性的突变的响应包括修改的对象，这样大大提高了客户端代码的效率。与查询一样，确定哪些突变对您的客户有用，这有助于告知架构的结构。</p><h6 id="构建突变反应"><a href="#构建突变反应" class="headerlink" title="构建突变反应"></a>构建突变反应</h6><p>单个突变可以修改多种类型，或同一类型的多个实例。例如，使用户能够“喜欢”博客文章的突变可能会增加a的likes计数Post 并更新的likedPosts列表User。这使得突变响应的结构看起来像什么不太明显。</p><p>此外，由于突变会修改数据，因此比查询引起错误的可能性要高得多。变异甚至可能导致部分错误，在该错误中，成功修改了一条数据而没有修改另一条数据。无论错误的类型如何，以一致的方式将错误传达回客户端都是很重要的。</p><p>为帮助解决这两个问题，建议MutationResponse您在架构中定义一个接口，以及实现该接口的对象类型的集合（每个突变一个）。</p><p>下面是什么MutationResponse接口的样子：</p><pre>interface MutationResponse {  code: String!  success: Boolean!  message: String!}</pre><p>这是一个实现对象类型：</p><pre>type UpdateUserEmailMutationResponse implements MutationResponse {  code: String!  success: Boolean!  message: String!  user: User}</pre><p>我们的updateUserEmail突变将指定UpdateUserEmailMutationResponse为返回类型（而不是User），其响应的结构如下：</p><pre>{  "data": {    "updateUser": {      "code": "200",      "success": true,      "message": "User email was successfully updated",      "user": {        "id": "1",        "name": "Jane Doe",        "email": "jane@example.com"      }    }  }}</pre><p>让我们按字段细分此字段：<br>code是代表数据传输状态的字符串。可以将其视为HTTP状态代码。<br>success是一个布尔值，指示突变是否成功。这允许客户端进行粗略检查，以了解是否存在故障。<br>message是描述突变结果的人类可读字符串。它打算在产品的UI中使用。<br>user由实现类型添加，UpdateUserEmailMutationResponse以将新更新的用户返回给客户端。</p><p>如果变异修改多种类型（例如我们前面的“喜欢”博客文章的示例），则其实现类型可以为每个被修改的类型包括一个单独的字段：</p><pre>type LikePostMutationResponse implements MutationResponse {  code: String!  success: Boolean!  message: String!  post: Post  user: User}</pre><p>由于我们的假设likePost突变会同时修改a Post和a 上的字段User，因此其响应对象包括这两种类型的字段。响应具有以下结构：</p><pre>{  "data": {    "likePost": {      "code": "200",      "success": true,      "message": "Thanks!",      "post": {        "id": "123",        "likes": 5040      },      "user": {        "likedPosts": ["123"]      }    }  }}</pre><p>遵循此模式可为客户提供有关每个请求的操作结果的有用的详细信息。有了这些信息，开发人员可以更好地应对其客户端代码中的操作失败。</p><h4 id="自定义标量类型和枚举类型"><a href="#自定义标量类型和枚举类型" class="headerlink" title="自定义标量类型和枚举类型"></a>自定义标量类型和枚举类型</h4><h4 id="联合与接口"><a href="#联合与接口" class="headerlink" title="联合与接口"></a>联合与接口</h4><h4 id="使用schema指令"><a href="#使用schema指令" class="headerlink" title="使用schema指令"></a>使用schema指令</h4><h4 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h4>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
