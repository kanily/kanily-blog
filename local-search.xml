<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>移动端适配方案</title>
    <link href="/2020/08/13/css/mobile/"/>
    <url>/2020/08/13/css/mobile/</url>
    
    <content type="html"><![CDATA[<p>###像素</p><h4 id="物理像素（设备像素）"><a href="#物理像素（设备像素）" class="headerlink" title="物理像素（设备像素）"></a>物理像素（设备像素）</h4><p>屏幕的物理像素，又被成为设备像素，是现实设备中最微小的物理部件，任何设备的屏幕的物理像素出厂时就确定了，且固定不变</p><h4 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h4><p>设备独立像素也成为密度无关像素，可以认为是计算机坐标的一个点，这个点可以代表一个可由程序使用的虚拟像素（例如css像素），然后有相关系统转换为物理像素</p><h4 id="设备像素比（devicePixelRatio）"><a href="#设备像素比（devicePixelRatio）" class="headerlink" title="设备像素比（devicePixelRatio）"></a>设备像素比（devicePixelRatio）</h4><p>简称dpr ，定义了物理像素和设备独立像素的对应关50系</p><pre>设备像素比 = 物理像素 / 独立设备像素以iphone6 为例  设备固有像素为 750 * 1334，设备宽度是 375 * 667，其 dpr 就是2可以通过 window.devicePixelRatio 获得dpr > 1 就是高清屏，一般dpr为整数</pre><h4 id="css像素"><a href="#css像素" class="headerlink" title="css像素"></a>css像素</h4><p>css、js中使用的一个长度单位。单位 px</p><p>注意：pc端1物理像素 等于1px，但是移动端1物理像素不等于 1px，1物理像素与 px的关系与以下因素有关</p><pre>1.屏幕布局的视口大小2.屏幕的分辨率（物理像素）</pre><p>对于一块屏幕，其物理像素是确定的。视觉视口尺寸是继承与布局视口的，而视觉视口里的宽度即是css的px数。故一块屏幕上的物理像素与px的关系就是物理像素与布局视口的px数的关系</p><pre><code class="hljs plain">比如 iPhone6 它的物理像素是750px， 如果没有设置布局视口 viewport 为 980px此时: 1物理像素长度 &#x3D; 980px &#x2F; 750px &#x3D; 1.3076px 的长度由于像素都是点阵的 一个物理像素点相当度 1.3076px * 1.3076px 方格当在meta中设置了如下配置时 &lt;meta name &#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt; 相当于把布局视口设置为设备的宽度（即上面讲到的设备独立像素）， 对于iphone6就是375此时： 1物理像素长度 &#x3D; 375px &#x2F; 750px &#x3D; 0.5 的长度，相当于 0.5px * 0.5px 方格</code></pre><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><h4 id="1-布局视口"><a href="#1-布局视口" class="headerlink" title="1.布局视口"></a>1.布局视口</h4><p> 在html中一般在meta中的name为viewport 字段就是控制的布局视口，布局视口一般都是浏览器厂商给的一个值。但是浏览器厂商一般为了能小屏幕也能友好的展示，把布局视口设置很大，一般在768px~1024ox之间，最常用的就是980px。这样用户就能看大绝大部分的内容，根据内容去缩放</p><p> 故布局视口是看不见的，浏览器厂商设置的固定值，eg：980px，并将980px内容缩放到手机屏幕内</p><p> 布局视口可以通过</p><pre><code class="hljs plain">document.documentElement.clientWidth</code></pre><h4 id="2-视觉视口"><a href="#2-视觉视口" class="headerlink" title="2.视觉视口"></a>2.视觉视口</h4><p>浏览器可视区域的大小，即用户可以看到的区域。（其宽度继承于布局视口的宽度）</p><pre><code class="hljs plain">window.innerwidth</code></pre><h4 id="3-理想视口"><a href="#3-理想视口" class="headerlink" title="3.理想视口"></a>3.理想视口</h4><p>布局视口虽然解决了移动端 查看pc网页的问题，但是完全忽略的手机本身的尺寸。所以苹果引入了理想视口，它对于设备来说就是最理想的布局视口,用户不需要缩放就可以完美展示整个页面</p><p>可以通过</p><pre><code class="hljs plain">window.screen.width</code></pre><p>移动端到底如何适配呢 最简单就是设置如下视口</p><pre><code class="hljs plain">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,user-scalable&#x3D;no&quot;&gt;</code></pre><p>使用上述方案定义布局视时，即布局视口等于理想视口，屏幕没有滚动条，不存在高清屏下，字体较小的问题。但是在不同的屏幕上，视觉宽度是不同的，不能简单的将所有的尺寸都设置为px，</p><h4 id="viewport缩放"><a href="#viewport缩放" class="headerlink" title="viewport缩放"></a>viewport缩放</h4><p>对于上面设置，在不同的屏幕上，css像素对应的物理像素具体的数值是不一致的</p><p>在普通屏幕上 dpr = 1 时，<br>1个css像素长度对应一个物理像素长度，1个css像素对应一个物理像素</p><p>在retina屏幕， dpr = 2</p><p>1个css像素长度对应 2个物理像素长度， 一个css像素 对应 4个物理像素</p><h4 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h4><p>#####方案一<br>固定高度 宽度自适应</p><p>使用理想视口的方案</p><pre><code class="hljs plain">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minumum-scale&#x3D;1,user-scalable&#x3D;no&quot; &gt;</code></pre><p>垂直方向使用固定的值，水平方向使用弹性布局，元素使用定值 百分比 flex 布局</p><h5 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h5><p>固定布局视口宽度，使用viewport 缩放</p><pre><code class="hljs plain">if(&#x2F;Android (\d+\.\d+)&#x2F;.test(navigator.userAgent))&#123;  var version &#x3D; parseFloat(RegExp.$1);  if(version&gt;2.3)&#123;    var phoneScale &#x3D; parseInt(window.screen.width)&#x2F;640;    if(&#x2F;MZ-M571C&#x2F;.test(navigator.userAgent))&#123;      document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, minimum-scale &#x3D; 0.5, maximum-scale&#x3D; 0.5&quot;&gt;&#39;);    &#125;else if(&#x2F;M571C&#x2F;.test(navigator.userAgent)&amp;&amp;&#x2F;LizhiFM&#x2F;.test(navigator.userAgent))&#123;      document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, minimum-scale &#x3D; 0.5, maximum-scale&#x3D; 0.5&quot;&gt;&#39;);    &#125;else&#123;      document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, minimum-scale &#x3D; &#39;+ phoneScale +&#39;, maximum-scale &#x3D; &#39;+ phoneScale +&#39;, target-densitydpi&#x3D;device-dpi&quot;&gt;&#39;);    &#125;  &#125;else&#123;    document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, target-densitydpi&#x3D;device-dpi&quot;&gt;&#39;);  &#125;&#125;else&#123;  document.write(&#39;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;640, user-scalable&#x3D;no, target-densitydpi&#x3D;device-dpi&quot;&gt;&#39;);&#125;</code></pre><p>方案三：</p><p>根据不同的屏幕动态写入font-size， 以rem作为宽度单位， 固定布局视口</p><pre><code class="hljs plain">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maxmum-scale&#x3D;1,user-scalable&#x3D;no&quot; &gt;</code></pre><p>以640px 设计稿 或者 750px 设计稿，</p><pre><code class="hljs plain">var width &#x3D; document.document.clientWidth;var rem &#x3D; width &#x2F; 7.5var rem width &#x2F; 6.4</code></pre><p>方案四 </p><p>以rem作为宽度单位，动态写入viewport 和 font-size 进行缩放</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Gallery</title>
    <link href="/2020/08/13/hello-world/"/>
    <url>/2020/08/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>摘要…</p><a id="more"></a><p>正文…</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><p><a href="source/data/promise/1.md">阅读更多…</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/BinarySearchTree</title>
    <link href="/2020/08/13/algorithm/BinarySearchTree/"/>
    <url>/2020/08/13/algorithm/BinarySearchTree/</url>
    
    <content type="html"><![CDATA[/** * 二叉搜索树 * 每个节点都有数据，另外含有两个指针，指向其他节点 * 特点：节点顺序基于节点值的大小，所有左节点的值都小于右节点的值 */var node = {    value: 124,    left: null,    right: null};function BinarySearchTree() {    this._root = null}BinarySearchTree.prototype = {    constructor: BinarySearchTree,    add: function (value) {        var node = {            value: value,            left: null,            right: null        },        current;        if (this._root === null) {            this._root = node;        } else {            current = this._root            while (true) {                if(value < current.value) {                    if (current.left === null) {                        current.left = node                        break;                    } else {                        current = current.left                    }                } else if (value >  current.right) {                    if (current.right === null) {                        current.right = node                        break                    } else {                        current = current.right                    }                } else {                    break                }            }        }    },    contains: function (value) {        var found = false,            current = this._root;        while (!found && current) {            if (value < current.value) {                current = current.right            } else if (value > current.value) {                current = current.left            } else {                found = true            }        }        return found        },    remove: function (value) {        var found = false,            parent = null,            current = this._root,            childCount,            replacement,            replacementParent;       // 定位要删除的节点 父节点要被记录              while(!found && current) {            if(value < current.value) {                parent = current                current = current.left            }else if (value > current.value) {                parent = current                current = current.right            } else {                found = true            }        }        if (found) {          // 计算节点数量            childCount = (current.left === null ? 0 : 1) + (current.right === null ? 0 : 1)            if(current === this._root) {                switch(childCount){                    case 0:                        this._root = null;                        break;                    case 1:                        this._root = current.right === null ? current.left : current.right                        break;                    case 2:                        //新的根节点是源根节点的做子节点                        //左子树的最右节点 直接前驱                        replacement = this._root.left                        while (replacement.right !== null) {                            replacementParent = replacement                            replacement = replacement.right                        }                        if(replacementParent !== null) {                            replacementParent.right = replacement.left                            replacement.right = this._root.right                            replacement.left = this._root.left                        }                        this._root = replacement                }            } else {                switch(childCount){                    case 0:                        if(current.value > parent.value) {                            parent.left = null;                        } else {                            parent.right = null                        }                        break;                    case 1:                        if(current.value > parent.value) {                        parent.left = current.left ? current.left.value : current.right.value                    } else {                        parent.right = current.left ? current.left.value : current.right.value                    }                    case 2:                      //TODO                        replacement = current.left                        replacementParent = current                        while (replacement.right !== null) {                            replacementParent = replacement                            replacement = replacement.right                        }                        replacementParent = replacement.left                         replacementParent.right = current.right                        replacementParent.left = current.left                        if (parent.value > replacement.value) {                            parent.left = replacement                        } else {                            parent.right = replacement                        }                }            }        }    },    size: function () {        var length = 0;        this.traverse(function(node){            length++;        })        return length    },    traverse: function (process) {        // 辅助函数遍历节点        function inOrder(node) {            if(node.left !== null) {                inOrder(node.left)            }            // call 使用指定的this 和单独给出的一个或多个参数调用一个函数，再次此处调用process            process.call(this, node);            if (node.right !== null) {                inOrder(node.right)            }        }        inOrder(this._root)    },    toArray: function () {        var result = [];        this.traverse(function(node){            result.push(node.value)        })        return result    },    toString: function () {        return this.toArray().toString();    },}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/BubbleSort</title>
    <link href="/2020/08/13/algorithm/BubbleSort/"/>
    <url>/2020/08/13/algorithm/BubbleSort/</url>
    
    <content type="html"><![CDATA[/** * 冒泡排序 * 比较前两个元素 -> 如果第一个元素应该排在第二个后面，则两者交换 -> 比较第二个与第三个元素  * 如果第二个元素应该在第三个后面，两者交换 -> 重复以上过程知道末尾 * 时间复杂度 平均复杂度O(n*n), 最好情况O(n), 最差情况(n*n) * 空间复杂度 O(1) * 稳定性 稳定 */function swap(items, firstIndex, secondIndex) {    var temp = items[firstIndex];    items[firstIndex] = items[secondIndex]    items[secondIndex] = temp}/** * 外层循环负责遍历，内层循环负责数组的元素比较 *  */function bubbleSort(items) {    var len = items.length,            i,            j,            stop;    for (i = 0; i < len; i++) {        var done = true        for(j = 0, stop = len-i-1; j < stop; j++) {            if(items[j] < item[j+1]) {                swap(items, j, j+1)                done = false            }        }        if (done) {            break;        }    }    return items}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/base64</title>
    <link href="/2020/08/13/algorithm/base64/"/>
    <url>/2020/08/13/algorithm/base64/</url>
    
    <content type="html"><![CDATA[function generateArray(length, arr = []) {  let randomNum = Math.floor((Math.random()*30)+2);  if(arr.indexOf(randomNum) === -1) {    arr.push(randomNum);  }  return arr.length < length ? generateArray(length, arr) : arr ;}function toFlat(arr, newArr = []) {  for (let key in arr) {    console.log(arr[key])    typeof arr[key] === 'number' ? newArr.push(arr[key]) : toFlat(arr[key], newArr);  }  return Array.from(new Set(newArr)).sort((a, b) =>{ return a - b});}// class LazyMan {//   constructor(name) {//     this.name = name//     console.log(`Hi I am ${name}`)//   }//   sleep(time) {//     setTimeout(() => {//       console.log(`等待了${time}`)//     }, time)//   }//   eat(some) {//     console.log(`I am eating ${some}`)//   }// }function LazyMan(name) {  if(! (this instanceof  LazyMan)) {    return  new LazyMan(name)  }  this.taskList = [];  this.next();  console.log(`Hi I am ${name}`);}LazyMan.prototype.sleep = function(time) {  let that = this  that.taskList.push({    delayTime: time * 1000,    callback() {      console.log(`等待了${time}s ...`)      that.next()    }  })  return this;}LazyMan.prototype.eat = function(food) {  let that = this  that.taskList.push({    delayTime: 0,    callback() {      console.log(`I am eating ${food}`)      that.next()    }  })  return that;}LazyMan.prototype.next = function() {  const taskList = this.taskList;  if ( taskList.length === 0 ) return;  const {delayTime, callback} = taskList[0]  setTimeout(() => {    callback && callback()    taskList.shift()    this.next()  },delayTime)}LazyMan('Tony').sleep(10).eat('lunch');function add() {  let args = [].slice.call(arguments);  let addArgs = args.length === 1 ? args[0] : args.reduce((pre, item) => {    return pre + item  })  function sumF() {    let addArgs2 = args.length === 1 ? args[0] : args.reduce((pre, item) => {      return pre + item    })    return addArgs += addArgs2  }  sumF.toString = function () {    return addArgs  }  return sumF;}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/linkedList</title>
    <link href="/2020/08/13/algorithm/linkedList/"/>
    <url>/2020/08/13/algorithm/linkedList/</url>
    
    <content type="html"><![CDATA[/** * 链表——一种基础数据结构 * 自身就是一个指针，指向头结点，相应的这个头节点又有个指针指向下一个节点，以此类推。 * 每个节点包含两块区域，数据区域包含该位置的值，另一个区域包含一个指针指向下一个节点 */function LinkList() {    this._length = 0;  // 长度属性    this._head = null; // 链表指向的第一个元素，一开始的链表为空}LinkList.prototype = {    add: function(data) {        var node = {            data: data,            next: null        },        current;        if (this._head === null) {            this._head = node        } else {            current = this._head;            while (current.next) {                current = current.next            }            current.next = node        }        this._length++    },    item: function(index) {        if (index > -1 && index < this._length) {            var current = this._head,            i = 0;            while (i++ < index) {                current = current.next;            }            return current.data;        } else {            return null;        }    },    remove: function(index) {        if (index > -1 && index < this._length) {            var current = this._head,                previous,                i = 0;            if (index === 0) {                this._head = current.next            } else {                // 找到正确的位置进行删除                while (i++ < index) {                    previous = current;                    current = current.next                }                previous.next = current.next            }            this._length--;            return current.data;        } else {            return null;        }    }}// 使用var list = new LinkedList();list.add('red')list.add('orange')list.add('yellow')function showStudent(ssn) {    var student = db.get(ssn);    if(student !== null) {        document.querySelector(`#{elementId}`).innerHTML = `${student.ssn}, ${student.firstname}, ${student.lastname}`;    } else {        throw  new Error('student is not found')    }}var find = curry(function (db, id) {    var obj = bd.get(id);    if(obj === null) {        throw new Error('Object not found');    }    return obj;})var csv = (student) {    return `${student.ssn}, ${student.firstname}, ${student.lastname}`;}var append = curry(function (elementId, info) {    document.querySelector(elementId).innerHTML = info;})var showStudent = run(append('#student-info'), csv, find(db));class Person {    constructor(firstname, lastname, ssn) {        this._firstname = firstname;        this._lastname = lastname;        this._ssn = ssn;        this._address = null;        this._birthYear = null;    }    get ssn() {        return this._ssn;    }    get firstname() {        return this._firstname;    }    get address() {        return this._address;    }    get birthYear() {        return this._birthYear;    }    set address(addr) {        this._address = addr;    }    toString() {        return `Person(${this._firstname}, ${this._lastname})`    }}class Student extends Person {    constructor(firtname, lastname, ssn, school) {        super(firtname, lastname, ssn);        this._school = school    }    get school() {        return this._school;    }}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/throttle</title>
    <link href="/2020/08/13/algorithm/throttle/"/>
    <url>/2020/08/13/algorithm/throttle/</url>
    
    <content type="html"><![CDATA[<p>##节流函数 throttle<br>###方案一</p><pre><code class="hljs plain">function throttle(fn, time) &#123;    let previous &#x3D; 0    return function(...args) &#123;        const temp &#x3D; +new Date();        if(temp - previous &gt; time) &#123;            previous &#x3D; temp;            fn.apply(this, args);        &#125;       &#125;&#125;</code></pre><h4 id="防抖函数-debounce"><a href="#防抖函数-debounce" class="headerlink" title="防抖函数 debounce"></a>防抖函数 debounce</h4><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><pre><code class="hljs plain">function debounce(fn, time)&#123;    let timer &#x3D; null;    return function(...args) &#123;        if(!timer) &#123;            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;                fn.call(this, args)            &#125;, time)           &#125;        clearTimeout(timer)    &#125;        &#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>prototype/this</title>
    <link href="/2020/08/13/prototype/this/"/>
    <url>/2020/08/13/prototype/this/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http/http</title>
    <link href="/2020/08/13/http/http/"/>
    <url>/2020/08/13/http/http/</url>
    
    <content type="html"><![CDATA[<h2 id="http-简介"><a href="#http-简介" class="headerlink" title="http 简介"></a>http 简介</h2><p>http 超文本传输协议，主要规定浏览器和服务器相互通信规则，它是基于TCP/IP通信协议来进行传递数据<br>浏览器发起一http请求， 首先建立TCP连接  也就是常说的三次握手， 接下来发起Http请求<br>一个http请求主要包括 请求行 请求头 请求正文<br>请求行：请求地址、请求的方法（get， post、put、delete）、请求状态<br>2** 成功<br>#excerpt_link: Read More…<br>3** 重定向<br>    301 永久重定向<br>    302 临时重定向<br>    304 not modify<br>4** 客户端错误<br>    400 Bad request 请求中有语法错误<br>    401 Unauthorize 未被授权<br>    403 forbidden<br>    404 Not found<br>5** 服务端错误<br>    500<br>    503 service unavailable<br>请求头<br> Accept<br> host<br> UserAgent<br> cookie （key value domin expires size httponly）4k 最多可以有20个 默认到浏览器关闭<br> connection keep-alive<br>请求体<br>http 响应请求<br> 响应行<br> 响应体<br>  cache-control<br>  content-type<br>  status<br>  expires<br>  date<br>  Last-Modified<br>结束<br>断开 TCP 连接 四次挥手</p><h2 id="https-http-ssl"><a href="#https-http-ssl" class="headerlink" title="https = http + ssl"></a>https = http + ssl</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>prototype/prototype</title>
    <link href="/2020/08/13/prototype/prototype/"/>
    <url>/2020/08/13/prototype/prototype/</url>
    
    <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><hr><p><strong>constructor</strong> 返回实例对象构造函数的引用，此值是对函数本身的引用</p><pre>function Person (name) {    this.name = name;}var p = new Person(name);p.constructor === Person</pre><p>构造函数本身就是函数，不过为了规范都会首字母大写， 主要<code>区别</code>在于使用 <em>new</em> 生成的实例函数就是构造函数，直接调用的就是普通函数 </p><h3 id="constructor-是只读的吗？"><a href="#constructor-是只读的吗？" class="headerlink" title="constructor 是只读的吗？"></a>constructor 是只读的吗？</h3><p>对引用类型来是可以修改的，对基本数据类型是 只读的</p><pre>function Parent() {    this.name = 'xiaoming';    this.age = '18';}Parent.prototype = {    method: funtion () {}}function Children() {}Children.prototype = new Parent();Children.prototype.foo = 'Hello world'//此时constructor 指向 ObjectChildren.prototype.constructor === Object //true//修正constructorChildren.prototype.constructor = Children</pre><h3 id="new-到底是如果实现的呢"><a href="#new-到底是如果实现的呢" class="headerlink" title="new 到底是如果实现的呢"></a>new 到底是如果实现的呢</h3><pre>function create () {    // 创建一个空对象    var obj = new Object(),    //2. 获得构造函数，同时删除arguments 里的第一个参数    Con = [].shift.call(arguments);    //3. 链接到原型，obj可以访问到构造函数的属性    Object.setPrototypeOf(obj, Con.prototype)    //4.绑定this实现继承，让其可以访问构造函数的属性    var result = Con.apply(obj, arguments)    //优先返回构造函数的对象    return result instanceof Object ? result : obj}</pre><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><p>每个构造函数对象拥有一个<strong>原型对象</strong>，对象以原型为模板，从原型继承方法和属性，这些属性和方法定义在构造器函数的 <strong>prototype</strong> 属性上，而非本身</p><h2 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a>_<em>proto_</em></h2><p>构造函数的 prototype 属性有个 _<em>proto__属性，这是一个访问器属性（即getter 函数和 setter函数），通过他可以访问到对象内部的 [[Prototype]](一个对象或null)<br>##<br><em>_prototype</em></em> 属性在es6后才被标准化，获取或者设置可以用</p><pre>    Object.setPrototypeOf()    Object.getPrototypeOf()</pre><p>##原型链<br>每个对象拥有原型对象，通过<strong>proto</strong>指针指向该对象的原型，并从中集成方法和属性， 同时原型对象也可能拥有原型，这样一层一层，最终会指向null；这种关系被称作原型链</p><h2 id="实现-instanceOf"><a href="#实现-instanceOf" class="headerlink" title="实现 instanceOf"></a>实现 instanceOf</h2><pre>function _instanceOf (instance, object){    // 获取对象的原型    const prototype = object.prototype;    //获取要检查对象的原型    let proto = instance.__proto__;    //遍历要检查的原型链，until the end of instance    while (__proto__ !== null) {        if (__proto__ === prototype) {            return true;        }        proto =  proto.__proto__;    }    return false;}</pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise 详解</title>
    <link href="/2020/08/13/promise/1/"/>
    <url>/2020/08/13/promise/1/</url>
    
    <content type="html"><![CDATA[<p>new Promise时， 需要传递一个 executor 执行器， 执行器立即执行</p><a id="more"></a><p>/**</p><ul><li><ol><li>new Promise时， 需要传递一个 executor 执行器， 执行器立即执行</li></ol></li><li><ol start="2"><li>executor 接受两个参数 分别是 resolve 和 reject</li></ol></li><li><ol start="3"><li>promise 只能从 pending 到 rejected， 或者 从 pending 到 resolved</li></ol></li><li><ol start="4"><li>promise 的状态一旦确认， 就不会再改变</li></ol></li><li><ol start="5"><li>promise 都有 then 方法， then方法接收两个参数， </li></ol></li><li>分别是 promise 成功回调的 onFulfilled 和 失败回调的 onRejected</li><li><ol start="6"><li>如果调用 then 时，promise已经成功，则执行 onFulfilled 并将 promise的值作为参数传进去</li></ol></li><li>如果promise已经失败， 那么执行 onRejected 并将 promise失败的原因作为参数传递进去</li><li>如果promise是pending状态，则把 onFulfilled 和 onRejected 函数存起来， 等到状态确定后，</li><li>再按照相应的对象执行（发布-订阅模式）</li><li><ol start="7"><li>onFulfilled 和 onRejected 的参数可以缺省</li></ol></li><li><ol start="8"><li>promise 可以 then 多次，promise的then 返回一个promise</li></ol></li><li><ol start="9"><li>如果then返回的是一个结果， 那么可以把这个结果作为参数，传递下一个then 的 onFulfilled成功的回调</li></ol></li><li><ol start="10"><li>如果then 返回的是一个异常， 那么可以把这个异常作为参数， 传递给下一个then 的 onRejected 失败回调</li></ol></li><li><ol start="11"><li>如果 then 返回的是一个promise, 那么需要等这个promise 那么等到这个promise 执行完</li></ol></li><li>promise执行成功就走下一个then成功， promise执行失败就走下一个then的失败</li><li>/</li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">"pending"</span>;<span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">"fulfilled"</span>;<span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">'rejected'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">excutor</span>) </span>&#123;  <span class="hljs-keyword">let</span> that = <span class="hljs-keyword">this</span>; <span class="hljs-comment">//缓存当前promise 实例对象</span>  that.status = PENDING; <span class="hljs-comment">// 初始状态</span>  that.value = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// fulfilled状态时 返回的信息</span>  that.reason = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// rejected状态时 拒绝的原因</span>  that.onFulfilledCallbacks = []; <span class="hljs-comment">//存储fulfilled 状态对应的onFulfilled函数</span>  that.onRejectedCallbacks = []; <span class="hljs-comment">//存储rejected 状态对应的onRejected 函数</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resovle</span> (<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-comment">//value 成功态时接受的终值</span>    <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;      <span class="hljs-keyword">return</span> value.then(resovle, reject)    &#125;    <span class="hljs-comment">//实践中要确保 onFulfilled 和 onRejected方法异步执行，</span>    <span class="hljs-comment">//且应该在then 方法调用的时候那一轮事件循环的执行栈执行结束之后</span>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-comment">// 调用resovle 回调对应的onFulfilled函数</span>      <span class="hljs-keyword">if</span> (that.status === PENDING) &#123;        <span class="hljs-comment">// 只能由pending状态 =》 fulfilled 状态（避免多次调用resovle reject）</span>        that.status = FULFILLED;        that.value = value;        that.onFulfilledCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;          callback(that.value)        &#125;);      &#125;    &#125;)  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-comment">// 调用reject 回调对应onRejected 函数</span>        <span class="hljs-keyword">if</span> (that.status === PENDING) &#123;          <span class="hljs-comment">// 只能由 pending =》 rejected （避免多次调用resovle reject）</span>          that.status = REJECTED;          that.reason = reason;          that.onRejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;            callback(that.reason)          &#125;)        &#125;    &#125;)  &#125;  <span class="hljs-comment">//捕获在excutor执行期炮数的异常</span>  <span class="hljs-keyword">try</span> &#123;    excutor(resovle, reject)  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    reject(e)  &#125;&#125;</code></pre><p>Promise.prototype.then = function(onFulfilled, onRejected) {<br>  const that = this;<br>  let newPromise;<br>  onFulfilled =<br>    typeof onFulfilled === “function” ? onFulfilled : value =&gt; value;<br>  onRejected =<br>   typeof onRejected === “function” ? onRejected : reason =&gt; {<br>     throw reason<br>   }</p><p>   if(that.status === FULFILLED) {<br>     return newPromise = new Promise((resovle, reject) =&gt; {<br>       setTimeout(() =&gt; {<br>         try {<br>           let x = onFulfilled(that.value)<br>           resovlePromise(newPromise, x, resovle, reject);<br>         } catch (error) {<br>           reject(error)<br>         }<br>       })<br>     })<br>   }</p><p>   if(that.status === REJECTED) {<br>     return newPromise = new Promise(() =&gt; {<br>       setTimeout(() =&gt; {<br>         try {<br>           let x = onRejected(that.reason)<br>           resovlePromise(newPromise, x, resovle, reject)<br>         } catch (error) {<br>           reject(error)<br>         }<br>       })<br>     })<br>   }</p><p>   if(that.status === PENDING) {<br>     that.onFulfilledCallbacks.push(() =&gt; {<br>        setTimeout(() =&gt; {<br>          try {<br>            let x = onFulfilled(that.value)<br>            resovlePromise(newPromise, x, resovle, reject)<br>          } catch (error) {<br>            reject(error)<br>          }<br>        })<br>     })</p><pre><code>that.onRejectedCallbacks.push(() =&gt;{  setTimeout(() =&gt; {    try {      let x = onRejected(that.reason)      resovlePromise(newPromise, x, resovle, reject)    } catch (error) {      reject(error)    }  })})</code></pre><p>  }</p><p>}</p><p>function resolvePromise (newPromise, x, resolve, reject) {<br>  let that = this;<br>  if(newPromise === x) {<br>    reject(new TypeError(‘Chaining cycle’));<br>  }<br>  if(x &amp; typeof x === ‘object’ || typeof x === ‘function’) {<br>    let used;<br>    try {<br>      let then = x.then;<br>      if(typeof then === ‘function’) {<br>        then.call(x, (y) =&gt; {<br>          if(used) return;<br>          used === true;<br>          resovlePromise(newPromise, y, resolve, reject);<br>        }, (reason) =&gt; {<br>          if(used) return;<br>          used === true;<br>          reject(reason);<br>        })<br>      }else {<br>        if(used) return;<br>        used = true;<br>        resolve(x);<br>      }<br>    } catch (error) {<br>      if(used) return;<br>      used = true;<br>      reject(error);<br>    }<br>  }else{<br>    resolve(x);<br>  }<br>}</p><p>// promise.finally<br>// 不管成功 or 失败 最终都会走到finally 还可以继续 then 且可以把值原封不动的传给后面的then<br>Promise.prototype.finally = function (callback) {<br>  return this.then((value) =&gt; {<br>    return Promise.resolve(callback()).then(() =&gt; {<br>      return value<br>    })<br>  }, (err) =&gt; {<br>    return Promise.resolve(callback().then(() =&gt; {<br>      throw err<br>    }))<br>  })<br>}</p><p>//promise.all（promises） 返回一个promise对象<br>/**</p><ul><li><ol><li>如果传入的是一个空的可迭代对象，那么此promise对象回调完成（resolve），</li></ol></li><li><p>只有这种情况是同步执行的，其他的都是返回一个异步完成</p></li><li><ol start="2"><li>如果传入参数不包含任何一个promise， 则返回一个异步完成</li></ol></li><li><ol start="3"><li>promises 所有的promise都完成时，或参数中不包含promise时 回调完成</li></ol></li><li><ol start="4"><li>如果一个 promise 失败，那么promise.all 返回的promise对象失败</li></ol></li><li><ol start="5"><li>在任何情况下，promises返回的promise的完成状态结果都是一个数组</li></ol></li><li><p>/</p><p>Promise.prototype.all = function (promises) {<br> return new Promise((resolve, rejected) =&gt; {<br>  let index = 0;<br>  let result = [];<br>  if (promises.length === 0) {</p><pre><code>resolve(result)</code></pre><p>  } else {</p><pre><code>function processValue (idx, data) {  result[i] = data;  if (++index === promises.length) {    resolve(result)  }}for (let i = 0; i &lt; promises.length; i++) {  //promises[i]可能是个普通值  Promise.resolve(promises[i]).then((data) =&gt; {    processValue(i, data)  }, (err) =&gt; {    rejected(err);    return;  })}</code></pre><p>  }<br> })<br>}</p></li></ul><p> //Promise.race()<br> /**</p><ul><li>返回一个promise函数，他将与第一个传递的promise相同的方式被完成，他可以是完成也可以是失败，</li><li>取决于第一个完成的方式是两个中的哪一个</li><li>如果传递的是一个空数组，那么primise将处于永远等待</li><li>如果迭代中包含一个或多个 非promise/resolve/reject的promise，那么promise.race将解析为迭代中找到的第一个值</li><li>/<br>Promise.prototype.race = function(promises) {<br>return new Promise((resovle, reject) =&gt; {<br> if(promises.length === 0) {<br>   return;<br> }else {<br>   for (let i = 0; i &lt; promises.length; i++) {<pre><code>Promise.resolve(promises[i]).then((data)=&gt; {  resolve(data);  return;}, (err) =&gt; {  reject(err);  return;})</code></pre>   }<br> }<br>})<br>}</li></ul><p>//Promise.allSettled<br>/**</p><ul><li><p>将一组promise实例作为参数，包装成一个新的promise实例，只有等到所有的promise都执行完成后</p></li><li><p>不管是fulfilled 或是 rejected 包装实例才会结束</p></li><li><p>/</p><p>//Promise.any<br>/**</p></li><li><p>将一组promise实例作为参数，包装成一个新的promise实例，实例参数只要有一个promise是resolve状态</p></li><li><p>包装的实例则返回resolve状态，如果实例参数都返回rejected状态，实例才返回 rejected</p></li><li><p>/</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/Array/index</title>
    <link href="/2020/08/13/algorithm/Array/index/"/>
    <url>/2020/08/13/algorithm/Array/index/</url>
    
    <content type="html"><![CDATA[/** 数组的扁平化* 已知如下数组：var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];* 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组* */Array.prototype.flat = function (arr, result) {  result  arr.forEach((item) => {    Array.isArray(item) ? arguments.callee(item) : item.push(newArr)  })  return newArr}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/Function/compose</title>
    <link href="/2020/08/13/algorithm/Function/compose/"/>
    <url>/2020/08/13/algorithm/Function/compose/</url>
    
    <content type="html"><![CDATA[/** * 函数的组合 */let toUpperCase = function (str) {    return str.toUpperCase(str);}let hello = function(name) {    return `hi, {name}!`;}let sayHello = function() {    return hello(toUpperCase('Tom'));}/** * 我们可以看到 hello 函数使用了 toUpperCase的返回值 类似于 * sayHello = f(g(x)), 这时我们可以写一个compose 函数 将这个函数做为参数*/function _compose(f, g) {    return function (x) {        return f(g(x));    }}/** * 如果 compose(f, g, h, i)? * 难道要写成 compose(f, compose(g, compose(h, i))? */function compose() {    let length = arguments.length;    let args = arguments;    return function () {        let start = length -1;        let result = args.apply(this, arguments);        while (start--) args[start].apply(this, result)        return result;    }}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm/Function/curry</title>
    <link href="/2020/08/13/algorithm/Function/curry/"/>
    <url>/2020/08/13/algorithm/Function/curry/</url>
    
    <content type="html"><![CDATA[/** * @name curry * @version 1.0 * @description 函数的柯里化  * @param fn * @param num * @example curry(add, 1, 2)*/function _curry(fn) {    const args = [].slice.apply(arguments, 1);    return function () {        return fn.apply(this, args.concat(...arguments))    }}/** * @name curry * @version 1.1 * @param fn * @description currying is a technique of translating an evaluation of a function  * that takes multiple arguments (or tuple arguments) into evaluating a sequence  * functions, each with a single function; * @param length fn的参数个数 * @example curry(add(1, 2)) */ function curry(fn, length) {    // 判断要curry的函数的参数个数      length = length || fn.length;    let slice = Array.prototype.slice;    return function () {        if(arguments.length < length) {            const args = [fn].concat(slice.apply(this, arguments))            return curry(_curry.apply(this, args), length - arguments.length);        } else {            return fn.apply(this, arguments)        }            } }]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Apollo-Server</title>
    <link href="/2020/07/06/Apollo-Server/index/"/>
    <url>/2020/07/06/Apollo-Server/index/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Apollo-Server-是什么"><a href="#Apollo-Server-是什么" class="headerlink" title="Apollo Server 是什么"></a>Apollo Server 是什么</h4><p> <a href="http://www.baidu.com" target="_blank" rel="noopener">Apollo Server</a> 是一种符合规范的开源 GraphQL服务器，能与任何GraphQL客户端（包括Apollo Client）兼容。并且可以使用任何来源数据去构建生产预发环境、生成 GraphQL API 文档的最佳方法。</p><p> 您可以将<strong>Apollo Server</strong>用作：</p><ul><li><p>独立的GraphQL服务器，包括在serverless环境中</p></li><li><p>现有应用的Node.js中间件的扩展（例如Express或Fastify）的附件</p></li><li><p>Federated data graph的网关</p><p><strong>Apollo Server</strong> 提供：</p></li><li><p>简单易用的设置，因此您的客户端开发人员可以快速开始获取数据</p></li><li><p>渐进式采用，使您可以根据需要添加功能</p></li><li><p>可以兼容任何数据源、构建工具、GraphQL客户端</p></li><li><p>生产就绪，使您能够更快地发布功能</p></li></ul><h3 id="开始使用-Apollo-Server"><a href="#开始使用-Apollo-Server" class="headerlink" title="开始使用 Apollo Server"></a>开始使用 Apollo Server</h3><blockquote><p>本教程主要引导你安装和配置Apollo Server。如果您刚刚开始使用GraphQL 或者 Apollo平台，我们推荐您先完成<a href="https://www.apollographql.com/docs/tutorial/introduction" target="_blank" rel="noopener">full-stack-tutorial</a>。</p></blockquote><p>本教程可以帮助您：</p><ul><li>对GraphQL原理有基本了解</li><li>定义一个代表数据集结构的GraphQL <strong>schema</strong></li><li>运行Apollo Server实例，使您可以依照你的schema执行查询</li></ul><p>本教程假定您熟悉命令行和JavaScript，并且已安装了最新版本的Node.js（8+）。</p><h4 id="第一步：创建一个新的项目"><a href="#第一步：创建一个新的项目" class="headerlink" title="第一步：创建一个新的项目"></a>第一步：创建一个新的项目</h4><p>1.在您首选的开发目录中，为新项目创建目录并 <code>cd</code> 进入该目录：</p><pre><code class="hljs plain">mkdir graphql-server-examplecd graphql-server-example</code></pre><p>2.使用<code>npm</code>（或您喜欢的另一个包管理器，例如Yarn）初始化一个新的Node.js项目：</p><pre><code class="hljs plain">npm init --yes</code></pre><p>您的项目目录现在包含一个<code>package.json</code>文件。</p><h4 id="第二步：安装依赖项"><a href="#第二步：安装依赖项" class="headerlink" title="第二步：安装依赖项"></a>第二步：安装依赖项</h4><p>运行Apollo Server的应用程序需要两个顶级依赖项：</p><ul><li><a href="https://www.npmjs.com/package/apollo-server" target="_blank" rel="noopener">apollo-server</a> 是Apollo Server本身的核心库，可帮助您定义数据的形状以及如何获取数据。</li><li><a href="https://www.npmjs.com/package/graphql" target="_blank" rel="noopener">graphql</a> 是用于构建GraphQL Schema并对其执行查询的库。</li></ul><p>运行以下命令以安装这两个依赖项并将它们保存在项目的<code>node_modules</code>目录中：</p><pre><code class="hljs plain">npm install apollo-server graphql</code></pre><p>还要<code>index.js</code>在项目的根目录中创建一个空文件：</p><pre><code class="hljs plain">touch index.js</code></pre><p>为简单起见，<code>index.js</code>将包含此示例应用程序的所有代码。</p><h4 id="第三步：定义您的GraphQL-Schema"><a href="#第三步：定义您的GraphQL-Schema" class="headerlink" title="第三步：定义您的GraphQL Schema"></a>第三步：定义您的GraphQL Schema</h4><p>每个GraphQL服务器（包括Apollo服务器）都使用一种<strong>Schema</strong>来定义客户端可以查询的数据结构。在此示例中，我们将创建一个服务器，用于按书名和作者查询书籍集合。</p><p><code>index.js</code>在您喜欢的编辑器中打开并将以下内容粘贴到其中：</p><pre><code class="hljs plain">const &#123; ApolloServer, gql &#125; &#x3D; require(&#39;apollo-server&#39;);&#x2F;&#x2F; A schema is a collection of type definitions (hence &quot;typeDefs&quot;)&#x2F;&#x2F; that together define the &quot;shape&quot; of queries that are executed against&#x2F;&#x2F; your data.const typeDefs &#x3D; gql&#96;  # Comments in GraphQL strings (such as this one) start with the hash (#) symbol.  # This &quot;Book&quot; type defines the queryable fields for every book in our data source.  type Book &#123;    title: String    author: String  &#125;  # The &quot;Query&quot; type is special: it lists all of the available queries that  # clients can execute, along with the return type for each. In this  # case, the &quot;books&quot; query returns an array of zero or more Books (defined above).  type Query &#123;    books: [Book]  &#125;&#96;;</code></pre><p>此代码段定义了一个简单有效的GraphQL Schema。客户将能够执行名为的查询books，并且我们的服务器将返回零个或多个Books 的数组。</p><h4 id="第四步：定义您的数据集"><a href="#第四步：定义您的数据集" class="headerlink" title="第四步：定义您的数据集"></a>第四步：定义您的数据集</h4><p>现在我们已经定义了数据的结构，我们可以定义数据本身了。Apollo服务器可以从您连接到的任何源（包括数据库，REST API，静态对象存储服务，甚至另一个GraphQL服务器）中获取数据。出于本教程的目的，我们将对一些示例数据进行硬编码。</p><p>将以下内容添加到的底部<code>index.js</code>：</p><pre><code class="hljs plain">const books &#x3D; [  &#123;    title: &#39;Harry Potter and the Chamber of Secrets&#39;,    author: &#39;J.K. Rowling&#39;,  &#125;,  &#123;    title: &#39;Jurassic Park&#39;,    author: &#39;Michael Crichton&#39;,  &#125;,];</code></pre><p>此代码段定义了客户端可以查询的简单数据集。注意，数组中的两个对象均与Book我们在架构中定义的类型的结构匹配。</p><h4 id="第五步：定义解析器"><a href="#第五步：定义解析器" class="headerlink" title="第五步：定义解析器"></a>第五步：定义解析器</h4><p>我们已经定义了数据集，但是Apollo Server不知道在执行查询时应该如何使用该数据集。为了解决这个问题，我们创建了一个 resolver。</p><p>让解析器告诉Apollo Server 如何获取与特定类型关联的数据。因为我们的Book数组是硬编码的，所以相应的解析器很简单。</p><p>将以下内容添加到的底部<code>index.js</code>：</p><pre><code class="hljs plain">&#x2F;&#x2F; Resolvers define the technique for fetching the types defined in the&#x2F;&#x2F; schema. This resolver retrieves books from the &quot;books&quot; array above.const resolvers &#x3D; &#123;  Query: &#123;    books: () &#x3D;&gt; books,  &#125;,&#125;;</code></pre><h4 id="第六步：创建ApolloServer实例"><a href="#第六步：创建ApolloServer实例" class="headerlink" title="第六步：创建ApolloServer实例"></a>第六步：创建ApolloServer实例</h4><p>我们已经定义了架构，数据集和解析器。现在，我们只需要在初始化时向Apollo Server提供此信息即可。</p><p>将以下内容添加到的底部index.js：</p><pre><code class="hljs plain">&#x2F;&#x2F; The ApolloServer constructor requires two parameters: your schema&#x2F;&#x2F; definition and your set of resolvers.const server &#x3D; new ApolloServer(&#123; typeDefs, resolvers &#125;);&#x2F;&#x2F; The &#96;listen&#96; method launches a web server.server.listen().then((&#123; url &#125;) &#x3D;&gt; &#123;  console.log(&#96;🚀  Server ready at $&#123;url&#125;&#96;);&#125;);</code></pre><h4 id="第七步：启动服务器"><a href="#第七步：启动服务器" class="headerlink" title="第七步：启动服务器"></a>第七步：启动服务器</h4><p>我们已经准备好启动服务器！从项目的根目录运行以下命令：</p><pre><code class="hljs plain">node index.js</code></pre><p>您应该看到以下输出：</p><pre>🚀 Server ready at http://localhost:4000/</pre><h4 id="第八步：执行第一个查询"><a href="#第八步：执行第一个查询" class="headerlink" title="第八步：执行第一个查询"></a>第八步：执行第一个查询</h4><p>现在，我们可以在服务器上执行GraphQL查询。要执行查询时，我们将使用一个名为GraphQL Playground的工具。</p><div class="note note-info">            <p>注意：如果将服务器部署到NODE_ENV设置为的环境，则production默认情况下将禁用GraphQL Playground和自省功能。要启用它们，您需要显式设置，playground: true并 introspection: true在的Constructor 选项ApolloServer内。</p>          </div><p>在服务器仍在运行的情况下，<a href="http://localhost:4000在浏览器中访问以打开GraphQL">http://localhost:4000在浏览器中访问以打开GraphQL</a> Playground。（在开发中运行GraphQL Playground时，Apollo Server会自动托管它。</p><p>GraphQL Playground UI包括</p><ul><li>用于编写查询的文本区域（左侧）</li><li>用于执行查询的“播放”按钮（中间的三角形按钮）</li><li>用于查看查询结果的文本区域（右侧）</li><li>查看架构检查和生成的文档的视图（通过右侧的选项卡）</li></ul><p>我们的服务器支持一个名为的查询<code>books</code>。让我们执行它！</p><p>这是用于执行查询的GraphQL 查询字符串<code>books</code>。</p><pre>{  books {    title    author  }}</pre><p>将此字符串粘贴到左侧文本区域，然后单击“播放”按钮。结果（来自我们的硬编码数据集）显示在右侧：</p><p>GraphQL的最重要概念之一是我们可以选择仅查询 所需的字段。<code>author</code>从查询字符串中删除并再次执行。响应更新为仅包括<code>title</code>每本书的字段！</p><h3 id="定义一个Schema"><a href="#定义一个Schema" class="headerlink" title="定义一个Schema"></a>定义一个Schema</h3><h4 id="schema基础"><a href="#schema基础" class="headerlink" title="schema基础"></a>schema基础</h4><p>GraphQL服务器使用<strong>Schema</strong>描述数据图的形状。Schema用来源于后端的数据字段来定义不同层级类型层次，schema还精确指定了能针对您的数据图、可用于客户端执行的query和mutation。<br>本文旨在介绍schema的基本构成以及如何为您的GraphQL服务器创建一个Schema。</p><h5 id="schema定义语言"><a href="#schema定义语言" class="headerlink" title="schema定义语言"></a>schema定义语言</h5><p>GraphQL规范包含一种人类可读的架构定义语言（或SDL），可用于定义Schema并将其存储为字符串</p><p>我们来定义两个对象类型：<code>Author</code> 和 <code>Book</code></p><pre>type Book {  title: String  author: Author}type Author {  name: String  books: [Book]}</pre><p>Schema 定义了类型的集合和类型的关系。在上面的例子中，每一个<code>Book</code>有一个<code>author</code>，每一个<code>Author</code>有<code>books</code>的列表。通过在整合的Schema中定义这些类型的关系，我们可以确保每一个客户端开发者可以准确查看可用数据，<br>并且通过单个优化查询请求该数据的特定子集</p><p>注意Schema并不关注数据的来源或者如何存储。它完全与实现无关。</p><h5 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h5><ul><li>标量类型</li><li>对象类型</li><li>Query 类型</li><li>Mutation 类型</li><li>输入类型<br>下面分别详细介绍这些内容。</li></ul><h6 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h6><p>标量类型类似于编程语言中的基本类型。他们总是解析具体的数据。</p><p>GraphQL的默认标量类型为：</p><ul><li><code>Int</code>：有符号的32位整数</li><li><code>Float</code>：带符号的双精度浮点值</li><li><code>String</code>：UTF-8字符序列</li><li><code>Boolean</code>：true或false</li><li><code>ID（序列化为String）</code>：唯一标识符，通常用于重新获取对象或用作缓存的键。尽管将其序列化为String，但<code>ID</code>并不旨在使其易于理解。</li></ul><p>这些原始类型涵盖了大多数用例。对于更特定的用例，您可以创建自定义标量类型。</p><h6 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h6><p>在GraphQL模式中定义的大多数类型都是对象类型。对象类型包含字段的集合，每个字段可以是标量类型或其他对象类型。</p><p>两种对象类型可以彼此包含为字段，就像前面的示例Schema中那样：</p><pre>type Book {  title: String  author: Author}type Author {  name: String  books: [Book]}</pre><h6 id="Query-类型"><a href="#Query-类型" class="headerlink" title="Query 类型"></a>Query 类型</h6><p>Query类型定义根据您的数据图执行查询的入口点。它类似于对象类型，但其名称始终为Query。</p><p>Query类型的每个字段定义不同入口点的名称和返回类型。Query我们的Schema类型可能类似于以下内容：</p><pre>type Query {  books: [Book]  authors: [Author]}</pre><p>这个查询类型定义了两个字段：<code>books</code> 和 <code>authors</code>。每个字段都返回一个列表<br>基于RestFul API，books 和 authors 很可能从不同的端点返回（eg： <code>/api/books</code> 和 <code>/api/authors</code>。而GraphQL的灵活性能保证通过一个请求返回这两个数据。</p><p><strong>构造一个query</strong><br>当你开始根据你的数据图来创建查询时，这些查询必须与你在Schema中定义好的结构相匹配。</p><p>基于我们例子中Schema，客户端执行下面的查询操作，将会返回所有的books和author 的列表</p><pre>query GetBooksAndAuthors {  books {    title  }  authors {    name  }}</pre><p>服务端会根据查询结构，将查询到的结果做如下返回</p><pre>{  "data": {    "books": [      {        "title": "Jurassic Park"      },      ...    ],    "authors": [      {        "name": "Michael Crichton"      },      ...    ]  }}</pre><p>尽管在某些情况下获取这两个单独的列表可能很有用，但是客户可能更喜欢获取一个图书列表，其中每本书的作者都包含在结果中。<br>因为我们的Schema的Book类型具有type的author字段Author，所以客户端可以改为这样构造其查询：</p><pre>query GetBooks {  books {    title    author {      name    }  }}</pre><p>再一次，我们的服务器将响应与查询结构匹配的结果：</p><pre>{  "data": {    "books": [      {        "title": "Jurassic Park",        "author": {          "name": "Michael Crichton"        }      },      ...    ]  }}</pre><h6 id="Mutation-类型"><a href="#Mutation-类型" class="headerlink" title="Mutation 类型"></a>Mutation 类型</h6><p>Mutation类型在结构和目的与Query类型类似。Query类型定义了读操作的入口点，而Mutation类型定义了写操作的入口点。</p><p>Mutation类型的每个字段定义不同入口点的标志和返回类型。Mutation我们的示例Schema的类型可能类似于以下内容：</p><pre>type Mutation {  addBook(title: String, author: String): Book}</pre><p>这个mutation类型定义了一个可用的mutation，<code>addBook</code>。这个mutation接收两个参数（title和author）并且返回一个新的<code>Book</code>对象。正如你所期望的，这个<code>Book</code>对象遵循我们在schema中定义的结构。</p><p><strong>构造一个mutation</strong><br>和query一样，mutations也应与我们的schema 定义的类型相匹配。下面的mutation 创建了一个新的<code>Book</code>而且请求已创建的对象的特定字段作为返回值。</p><pre>mutation CreateBook {  addBook(title: "Fox in Socks", author: "Dr. Seuss") {    title    author {      name    }  }}</pre><p>服务端将根据我们设计的mutation结构返回结果</p><pre>{  "data": {    "addBook": {      "title": "Fox in Socks",      "author": {        "name": "Dr. Seuss"      }    }  }}</pre><p>一个客户端请求可能包含多个需要执行的mutation。为了避免出现竞态，mutations的执行是线性的（根据列出的顺序）</p><p>学习更多关于mutations的设计</p><h6 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h6><p>输入类型是特殊的对象类型，它允许你传递一个对象作为参数进行query和mutation操作（与仅支持传标量类型相对）。输入类型可以帮助保持操作标识的整洁，就像在JavaScript函数中接受单个<code>options</code>对象比重复添加参数更干净一样。</p><p>看一下这个提交创建blog的mutation操作：</p><pre>type Mutation {  createPost(title: String, body: String, mediaUrls: [String]): Post}</pre><p>与接收三个参数相对，下面这个mutation只接受一个输入类型（包含这三个参数）。如果我们在将来决定增加一个参数会显得格外的方便，例如 <code>author</code></p><p>定义输入类型和对象类型很相似， 唯一不同就是我们需要使用 <code>input</code>关键字</p><pre>type Mutation {  createPost(post: PostAndMediaInput): Post}input PostAndMediaInput {  title: String  body: String  mediaUrls: [String]}</pre><p>输入类型不仅促进了PostAndMediaInput类型在我们Schema中的传递，而且提供了给字段增加注释空间，该描述可以自动的暴露给GraphQL可用工具。</p><pre>input PostAndMediaInput {  "A main title for the post"  title: String  "The text body of the post."  body: String  "A list of URLs to render in the post."  mediaUrls: [String]}</pre><p>当多个操作需要完全相同的数据集合时，输入类型有时会很有用，但是您应该谨慎地复用它们。操作最终可能会在其所需的参数之间产生分歧。</p><p><strong>不要对query和mutation使用相同</strong>的输入类型。在许多情况下，mutation所需的参数对于相应的query是可选的。</p><h5 id="Schema的演变"><a href="#Schema的演变" class="headerlink" title="Schema的演变"></a>Schema的演变</h5><p>随着你的组织成长与演变，你的数据图也会相应的成长。新的产品和特性会引入新的Schema类型和字段。为了追踪这段时间的变化，你应该用版本控制去维护你的定义的Schema。</p><p>大多数的Schema的增加是安全且向后兼容的。但是，发生的变化产生的删除和修改行为对于一个或更多已存在的应用可能是破坏性的改变。下面的schema改变会具有潜在的破坏性：</p><ul><li>删除一个类型或字段</li><li>重命名一个类型或字段</li><li>增加一个可为空字段</li><li>删除一个字段参数</li></ul><p>诸如Apollo Studio[<a href="https://studio.apollographql.com]之类的图形管理工具可帮助您了解潜在的Schema更改是否会影响您的正在使用客户端。Studio还通过操作安全列表提供字段级性能指标，Schema历史记录跟踪和高级安全性。">https://studio.apollographql.com]之类的图形管理工具可帮助您了解潜在的Schema更改是否会影响您的正在使用客户端。Studio还通过操作安全列表提供字段级性能指标，Schema历史记录跟踪和高级安全性。</a></p><h5 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h5><p>GraphQL的Schema定义语言（SDL）支持启用markdown的文档字符串。这些可帮助数据图的使用者发现字段并学习如何使用它们。</p><p>以下代码段显示了如何同时使用单行字符串文字和多行块：</p><pre>"Description for the type"type MyObjectType {  """  Description for field  Supports **multi-line** description for your [API](http://example.com)!  """  myField: String!  otherField(    "Description for argument"    arg: Int  )}</pre><p>文档完善的schema可以提升开发者体验，因为GraphQL开发者工具（例如Apollo VS Code extension 和 GraphQL Playground）可以根据我们提供的描述自动填写字段名。而且 Apollo Studio在使用其指标报告和客户端感知功能时，会在字段使用情况和性能详细信息的旁边显示说明</p><h5 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h5><p>GraphQL规范是很灵活的而且不强制特定的命名规范。但是在组织中建立一个约定集合确保持续集成是很有用的。我们推荐如下：</p><ul><li>字段名 使用<code>camelCase</code>命名。大部分GraphQL客户端都使用 JavaScript, Java, Kotlin, or Swift，我们都推荐使用<code>camelCase</code>命名变量名</li><li>类型名 使用<code>PascalCase</code>命名。这与上述语言中定义类的方式匹配</li><li>枚举名 使用<code>PascalCase</code></li><li>枚举值 使用<code>ALL_CAPS</code>，因为它们类似于常量</li></ul><p>这些约定有助于确保大多数客户端不需要定义额外的逻辑即可转换服务器返回的结果</p><h5 id="query-驱动的Schema设计"><a href="#query-驱动的Schema设计" class="headerlink" title="query 驱动的Schema设计"></a>query 驱动的Schema设计</h5><p>当GraphQL schema的执行操作是依据客户端的需求而设计时，其功能最为强大。尽管您可以构造类型，使它们与后端数据存储的结构匹配，但您duck不必这样！单个对象类型的字段可以许多不同来源的数据所填充。<strong>根据数据的使用方式（而不是数据的存储方式）设计Schema</strong>。</p><p>如果您的数据存储区包含客户端尚不需要的字段或关系，请从您的Schema中将其忽略。向Schema中添加新字段比删除某些客户端正在使用的现有字段更加容易和安全。</p><p><strong>query 驱动的Schema设计示例</strong><br>假设我们正在创建一个Web应用程序，其中列出了我们地区内的近期活动。我们希望该应用显示每个事件的名称，日期和位置，以及天气预报。</p><p>在这种情况下，我们希望Web应用能够执行具有类似于以下内容的结构的查询</p><pre>query EventList {  upcomingEvents {    name    date    location {      name      weather {        temperature        description      }    }  }}</pre><p>因为我们知道这是对我们的客户有帮助的数据结构，所以我们可以这样设计schema的结构：</p><pre>type Query {  upcomingEvents: [Event]}type Event {  name: String  date: String  location: Location}type Location {  name: String  weather: WeatherInfo}type WeatherInfo {  temperature: Float  description: String}</pre><p>如上所述，可以使用来自不同数据源（或多个数据源）的数据填充每一个类型中。例如，该<code>Event类型</code>的<code>name</code>和<code>date</code>字段可能从后端数据库获取``，而该WeatherInfo类型的可能来自第三方Weather API的数据。</p><h5 id="设计mutation"><a href="#设计mutation" class="headerlink" title="设计mutation"></a>设计mutation</h5><p>在GraphQL中，建议每个mutation的返回值都包含该mutation修改的数据。这使客户端无需发送后续查询即可获取最新的持久化数据。</p><p>一个Schema，支持更新email的User会包括以下内容：</p><pre> type Mutation {   # This mutation takes id and email parameters and responds with a User   updateUserEmail(id: ID!, email: String!): User } type User {   id: ID!   name: String!   email: String! }</pre><p>然后，客户端可以针对具有以下结构的schema执行mutation：</p><pre>mutation updateMyUser {  updateUserEmail(id: 1, email: "jane@example.com"){    id    name    email  }}</pre><p>GraphQL服务器执行更改并为用户存储新的电子邮件地址后，它将使用以下内容响应客户端：</p><pre>{  "data": {    "updateUserEmail": {      "id": "1",      "name": "Jane Doe",      "email": "jane@example.com"    }  }}</pre><p>虽然它不是强制性的mutation的返回包括修改的对象，这样大大提高了客户端代码的效率。与查询一样，确定哪些mutation对您的客户有用，这有助于告知架构的结构。</p><h6 id="构建mutation"><a href="#构建mutation" class="headerlink" title="构建mutation"></a>构建mutation</h6><p>单个mutation可以修改多种类型，或同一类型的多个实例。例如，使用户能够“喜欢”博客文章的mutation可能会增加<code>Post</code>的<code>likes</code>计数，并更新的<code>likedPosts</code>的<code>User</code>列表。这使得mutation返回的结构不太明晰。</p><p>此外，由于mutation会修改数据，因此比查询引起错误的可能性要高得多。mutation甚至可能导致部分错误，比如成功修改了一条数据而没有修改另一条数据。无论错误的类型如何，以一致的方式将错误传达回客户端都是很重要的。</p><p>为帮助解决这两个问题，建议您在架构中定义一个<code>MutationResponse</code>接口，以及用对象类型的集合实现该接口（每个mutation一个）。</p><p>下面是什么MutationResponse接口的样子：</p><pre>interface MutationResponse {  code: String!  success: Boolean!  message: String!}</pre><p>这是一个实现对象类型：</p><pre>type UpdateUserEmailMutationResponse implements MutationResponse {  code: String!  success: Boolean!  message: String!  user: User}</pre><p>我们的updateUserEmail的mutation将指定UpdateUserEmailMutationResponse为返回类型（而不是User），其响应的结构如下：</p><pre>{  "data": {    "updateUser": {      "code": "200",      "success": true,      "message": "User email was successfully updated",      "user": {        "id": "1",        "name": "Jane Doe",        "email": "jane@example.com"      }    }  }}</pre><p>让我们按字段细分：</p><ul><li>code是代表数据传输状态的字符串。可以将其视为HTTP状态代码。</li><li>success是一个布尔值，指示mutation是否成功。这允许客户端进行粗略检查，以了解是否存在故障。</li><li>message是描述mutation结果的可读性字符串。可以在产品的UI中使用。</li><li>user由实现类型添加，UpdateUserEmailMutationResponse以将新更新的用户返回给客户端。</li></ul><p>如果mutation修改多种类型（例如我们前面的“喜欢”博客文章的示例），则其实现类型可以为每个被修改的类型包括一个单独的字段：</p><pre>type LikePostMutationResponse implements MutationResponse {  code: String!  success: Boolean!  message: String!  post: Post  user: User}</pre><p>由于我们的假设likePost会同时修改Post和User，因此其返回对象包括这两种类型的字段。返回值具有以下结构：</p><pre>{  "data": {    "likePost": {      "code": "200",      "success": true,      "message": "Thanks!",      "post": {        "id": "123",        "likes": 5040      },      "user": {        "likedPosts": ["123"]      }    }  }}</pre><p>遵循此模式为客户端关每个请求的操作结果提供有用的详细信息。有了这些信息，开发人员可以更好地应对其客户端代码中的操作失败。</p><h4 id="自定义标量类型和枚举类型"><a href="#自定义标量类型和枚举类型" class="headerlink" title="自定义标量类型和枚举类型"></a>自定义标量类型和枚举类型</h4><h2 id="为schema添加自定义标量和枚举类型"><a href="#为schema添加自定义标量和枚举类型" class="headerlink" title="为schema添加自定义标量和枚举类型"></a>为schema添加自定义标量和枚举类型</h2><p>该GraphQL规范包括以下默认标量类型：<code>Int</code>，<code>Float</code>，<code>String</code>，<code>Boolean</code>和<code>ID</code>。尽管这涵盖了大多数用例，但有些需要支持自定义<br>原子数据类型（例如Date），或向现有类型添加验证。为此，GraphQL允许自定义标量类型。枚举类似于自定义标量，其限制是它们的值只能是字符串的预定义列表之一。</p><h5 id="自定义标量"><a href="#自定义标量" class="headerlink" title="自定义标量"></a>自定义标量</h5><p>要定义自定义标量，请使用以下符号将其添加到Schema字符串：</p><pre>scalar MyCustomScalar</pre><p>然后，在resolver map中<code>MyCustomScalar</code>通过GraphQLScalarType传递类的实例，定义自定义标量的行为。可以使用依赖项或源代码定义此实例。</p><p>有关GraphQL类型系统的更多信息，请参考官方文档或学习GraphQL教程。</p><p>请注意，Apollo Client当前并不能自动解析自定义标量，因此无法自动在客户端上逆转序列化。</p><h6 id="使用-package"><a href="#使用-package" class="headerlink" title="使用 package"></a>使用 package</h6><p>在这里，我们以<code>graphql-type-json</code>包为例，演示可以做什么。此npm包定义了JSON GraphQL标量类型。</p><p>将graphql-type-json包添加到项目的依赖项中：</p><pre>$ npm install graphql-type-json</pre><p>在代码中，要求使用npm包中定义的类型并使用它：</p><pre>const { ApolloServer, gql } = require('apollo-server');const GraphQLJSON = require('graphql-type-json');const schemaString = gql`  scalar JSON  type Foo {    aField: JSON  }  type Query {    foo: Foo  }`;const resolveFunctions = {  JSON: GraphQLJSON};const server = new ApolloServer({ typeDefs: schemaString, resolvers: resolveFunctions });server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><p>备注：<code>GraphQLJSON</code>是一个<code>GraphQLScalarType</code>实例。</p><h6 id="自订执行GraphQLScalarType个体"><a href="#自订执行GraphQLScalarType个体" class="headerlink" title="自订执行GraphQLScalarType个体"></a>自订执行GraphQLScalarType个体</h6><p>定义GraphQLScalarType实例可以提供对自定义标量的更多控制，并且可以通过以下方式将其添加到Apollo服务器：</p><pre>const { ApolloServer, gql } = require('apollo-server');const { GraphQLScalarType, Kind } = require('graphql');const myCustomScalarType = new GraphQLScalarType({  name: 'MyCustomScalar',  description: 'Description of my custom scalar type',  serialize(value) {    let result;    // Implement custom behavior by setting the 'result' variable    return result;  },  parseValue(value) {    let result;    // Implement custom behavior here by setting the 'result' variable    return result;  },  parseLiteral(ast) {    switch (ast.kind) {      case Kind.Int:      // return a literal value, such as 1 or 'static string'    }  }});const schemaString = gql`  scalar MyCustomScalar  type Foo {    aField: MyCustomScalar  }  type Query {    foo: Foo  }`;const resolverFunctions = {  MyCustomScalar: myCustomScalarType};const server = new ApolloServer({ typeDefs: schemaString, resolvers: resolverFunctions });server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><h5 id="自定义标量示例"><a href="#自定义标量示例" class="headerlink" title="自定义标量示例"></a>自定义标量示例</h5><p>让我们看几个示例，以演示如何定义自定义标量类型。</p><h5 id="日期标量"><a href="#日期标量" class="headerlink" title="日期标量"></a>日期标量</h5><p>目标是定义Date用于Date从数据库返回值的数据类型。假设我们正在使用使用本机JavaScript Date数据类型的MongoDB驱动程序。Date使用getTime()方法可<br>以轻松地将数据类型序列化为数字。因此，我们希望GraphQL服务器Date在序列化为JSON时以数字形式发送和接收。此数字将解析为Date服务器上代表日期值的。在<br>客户端上，用户可以简单地根据接收到的数值创建一个新日期。</p><p>下面是我们来实现<code>Date</code>数据类型， 首先在Schema</p><pre>const typeDefs = gql`  scalar Date  type MyType {    created: Date  }`</pre><p>接下来是解析器</p><pre>const { GraphQLScalarType } = require('graphql');const { Kind } = require('graphql/language');const resolvers = {  Date: new GraphQLScalarType({    name: 'Date',    description: 'Date custom scalar type',    parseValue(value) {      return new Date(value); // value from the client    },    serialize(value) {      return value.getTime(); // value sent to the client    },    parseLiteral(ast) {      if (ast.kind === Kind.INT) {        return parseInt(ast.value, 10); // ast value is always in string format      }      return null;    },  }),};const server = new ApolloServer({ typeDefs, resolvers });server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><p>在这个例子中，我们会根据<a href="https://www.npmjs.com/package/graphql" target="_blank" rel="noopener">graphql</a>官方文档的标量类型来陈述GraphQL如何校验数据库中为奇数数字段，首先Schema，</p><pre>const typeDefs = gql`  scalar Odd  type MyType {    oddValue: Odd  }`</pre><p>下一步，resolver：</p><pre>const { ApolloServer, gql } = require('apollo-server');const { GraphQLScalarType } = require('graphql');const { Kind } = require('graphql/language');function oddValue(value) {  return value % 2 === 1 ? value : null;}const resolvers = {  Odd: new GraphQLScalarType({    name: 'Odd',    description: 'Odd custom scalar type',    parseValue: oddValue,    serialize: oddValue,    parseLiteral(ast) {      if (ast.kind === Kind.INT) {        return oddValue(parseInt(ast.value, 10));      }      return null;    },  }),};const server = new ApolloServer({ typeDefs, resolvers });server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><p>枚举类型和标量类型很相似，但是枚举类型只能定义Schema中一部分值。枚举类型在比如用户需要在列表清单做选择是这种情况下很适用。除此之外，枚举类型可以提高开发速度，<br>因为他们可以在像GraphQL Playground工具中自动带入。<br>在 Schema 中， 一个枚举类型如下</p><pre>enum AllowedColor {  RED  GREEN  BLUE}</pre><p>枚举类型可以用在任何标量类型可以用位置</p><pre>type Query {  favoriteColor: AllowedColor # As a return value  avatar(borderColor: AllowedColor): String # As an argument}</pre><p>使用JSON串把枚举值作为变量传递：</p><pre>query GetAvatar($color: AllowedColor) {  avatar(borderColor: $color)}</pre><pre>{  "color": "RED"}</pre><p>整合在一起</p><pre>const { ApolloServer, gql } = require('apollo-server');const typeDefs = gql`  enum AllowedColor {    RED    GREEN    BLUE  }  type Query {    favoriteColor: AllowedColor # As a return value    avatar(borderColor: AllowedColor): String # As an argument  }`;const resolvers = {  Query: {    favoriteColor: () => 'RED',    avatar: (parent, args) => {      // args.borderColor is 'RED', 'GREEN', or 'BLUE'    },  }};const server = new ApolloServer({ typeDefs, resolvers });server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><h6 id="内部值"><a href="#内部值" class="headerlink" title="内部值"></a>内部值</h6><p>有时后端在内部为枚举强制使用与公共API中不同的枚举值。在此示例中，API包含<code>RED</code>，但是我们在resolvers使用#f00代替。在<code>resolvers</code>ApolloServer传参时允许<br>给枚举添加自定义的值：</p><pre>const resolvers = {  AllowedColor: {    RED: '#f00',    GREEN: '#0f0',    BLUE: '#00f',  }};</pre><p>这些根本不更改公共API，resolvers接受内部值而不是Schema值，如下所示：</p><pre>const resolvers = {  AllowedColor: {    RED: '#f00',    GREEN: '#0f0',    BLUE: '#00f',  },  Query: {    favoriteColor: () => '#f00',    avatar: (parent, args) => {      // args.borderColor is '#f00', '#0f0', or '#00f'    },  }};</pre><p>在大多数情况下，除非有另一个库进行互操作期望值有不同的表现形式，否则不会使用枚举的此功能。</p><h4 id="Unions-和-interfaces"><a href="#Unions-和-interfaces" class="headerlink" title="Unions 和 interfaces"></a>Unions 和 interfaces</h4><p>如何在Schema中添加 Unions 和 interfaces </p><p>当同一字段拥有不同类型是，Unions 和 interfaces是非常强大的</p><h5 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h5><p><code>Unions</code>类型认为一个字段可以返回至少一个对象类型，但是字段本身没有准确的类型。<code>Unions</code>类型对从单个字段返回的不相关数据类型非常有用。<br>类型定义如下所示</p><pre>const { gql } = require('apollo-server');const typeDefs = gql`  union Result = Book | Author  type Book {    title: String  }  type Author {    name: String  }  type Query {    search: [Result]  }`;</pre><p>由于查询请求联合字段，因此对联合类型的字段进行的查询必须指定包含所需字段的对象类型。通过__resolveType解析器图中的一个额外字段解决了这种歧义。<br>__resolveType定义结果的类型超出GraphQL执行环境的可用选项。</p><pre>const resolvers = {  Result: {    __resolveType(obj, context, info){      if(obj.name){        return 'Author';      }      if(obj.title){        return 'Book';      }      return null;    },  },  Query: {    search: () => { ... }  },};const server = new ApolloServer({  typeDefs,  resolvers,});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`)});</pre><p>对于这些结果的可能查询如下所示。该查询表明需要使用__resolveType，因为它会根据类型请求不同的数据，</p><pre>{  search(contains: "") {    ... on Book {      title    }    ... on Author {      name    }  }}</pre><h5 id="interface-类型"><a href="#interface-类型" class="headerlink" title="interface 类型"></a>interface 类型</h5><p>interface 类型是当使用抽象类型来构建和使用GraphQL Schemas 的有效方法。抽象类型不能直接在Schema中使用，但可以用构建块来创建显式类型。<br>想想当其中不同类型的书共享一组共同的属性，例如课本和涂色书。这些书可以用 interface 类型来构建：</p><pre>interface Book {  title: String  author: Author}</pre><p>当然，我们不能直接使用此interface类型来查询书籍，但可以使用它来实现具体类型。想象一下应用程序中页面，该页面要显示所有书籍的提要，而无需关心具体<br>类型。要创建此类功能，我们可以定义以下内容：</p><pre>type TextBook implements Book {  title: String  author: Author  classes: [Class]}type ColoringBook implements Book {  title: String  author: Author  colors: [Color]}type Query {  schoolBooks: [Book]}</pre><p>在此示例中，我们已使用<code>Book</code> interface 作为<code>TexBook</code> 和<code>ColoringBook</code>的基础类型。schoolBooks字段表示返回一个书列表（即[Book]）。</p><p>与Union 类型类似，在resolver映射中Interface类型需要一个额外的<code>__resolveType</code>字段来确定需要处理为哪种类型。</p><pre>const resolvers = {  Book: {    __resolveType(book, context, info){      if(book.classes){        return 'TextBook';      }      if(book.colors){        return 'ColoringBook';      }      return null;    },  },  Query: {    schoolBooks: () => { ... }  },};</pre><p>现在，我们简化了实现Book的过程，是因为消除了返回何种类型Book的疑虑。根据Schema的查询可能返回以下内容：TextBook和ColoringBook</p><pre>query GetBooks {  schoolBooks {    title    author  }}</pre><p>这对于常见内容、用户角色系统等都非常有帮助!<br>此外，如果我们需要返回的字段仅由TextBooks或ColoringBooks（不是两者都提供）提供，则可以从查询中的抽象类型请求片段。这些片段要根据具体条件填写；<br>如下，仅会向ColoringBook返回colors，而只有TextBook具有classes：</p><pre>query GetBooks {  schoolBooks {    title    ... on TextBook {      classes {        name      }    }    ... on ColoringBook {      colors {        name      }    }  }}</pre><h4 id="使用schema指令"><a href="#使用schema指令" class="headerlink" title="使用schema指令"></a>使用schema指令</h4><p>使用schema指令可以转变Schema类型、字段、参数</p><p>指令是由标识符<code>@</code>，命名参数可选，其后可出现任何符合GraphQL query或schema 语言的语法的形式。下面是 GraphQL规范草案的示例，说明了<br>其中几种可能性：</p><pre>directive @deprecated(  reason: String = "No longer supported") on FIELD_DEFINITION | ENUM_VALUEtype ExampleType {  newField: String  oldField: String @deprecated(reason: "Use `newField`.")}</pre><p>正如你所看到的，使用<code>@deprecated(reason: ...)</code> 属于（oldField），这个语法可能会让你想起其他语言中“装饰器”。<br>指令通过<code>directive @deprecated ... on ...</code>声明，使用@deprecated(reason: …)语法使用。</p><h5 id="默认指令"><a href="#默认指令" class="headerlink" title="默认指令"></a>默认指令</h5><p>GraphQL提供数个指令：@deprecated，@skip，和@include。</p><ul><li>@deprecated(reason: String) -将字段标记为已弃用消息</li><li>@skip(if: Boolean!) -GraphQL将通过不调用解析器来跳过该字段（如果为true）</li><li>@include(if: Boolean!) -如果为true，则为带注释的字段调用解析器<h5 id="使用自定义Schema指令"><a href="#使用自定义Schema指令" class="headerlink" title="使用自定义Schema指令"></a>使用自定义Schema指令</h5>要使用自定义Schema指令，请通过<code>schemaDirectives</code>参数将执行类传递给Apollo Server，该参数是一个将指令名称映射到执行指令的对象：<pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require('apollo-server');const { defaultFieldResolver } = require('graphql');</li></ul><p>// Create (or import) a custom schema directive<br>class UpperCaseDirective extends SchemaDirectiveVisitor {<br>  visitFieldDefinition(field) {<br>    const { resolve = defaultFieldResolver } = field;<br>    field.resolve = async function (…args) {<br>      const result = await resolve.apply(this, args);<br>      if (typeof result === ‘string’) {<br>        return result.toUpperCase();<br>      }<br>      return result;<br>    };<br>  }<br>}</p><p>// Construct a schema, using GraphQL schema language<br>const typeDefs = gql`<br>  directive @upper on FIELD_DEFINITION</p><p>  type Query {<br>    hello: String @upper<br>  }<br>`;</p><p>// Provide resolver functions for your schema fields<br>const resolvers = {<br>  Query: {<br>    hello: (parent, args, context) =&gt; {<br>      return ‘Hello world!’;<br>    },<br>  },<br>};</p><p>// Add directive to the ApolloServer constructor<br>const server = new ApolloServer({<br>  typeDefs,<br>  resolvers,<br>  schemaDirectives: {<br>    upper: UpperCaseDirective,<br>  }<br>});</p><p>server.listen().then(({ url }) =&gt; {<br>  console.log(<code>🚀 Server ready at ${url}</code>)<br>});<br></pre><br>实现UpperCaseDirective负责更改解析器并在必要时修改schema。</p><h5 id="创建自己的指令"><a href="#创建自己的指令" class="headerlink" title="创建自己的指令"></a>创建自己的指令</h5><p>先要了解应用自己Schema指令，请阅读下面文档</p><h4 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h4><p>执行自定义指令去转换Schema类型，字段和参数<br>在学习如何执行schema指令之前，本节将提供关于Schema指令及其使用的必要背景。</p><h4 id="Schema执行指令"><a href="#Schema执行指令" class="headerlink" title="Schema执行指令"></a>Schema执行指令</h4><p>由于GraphQL规范未讨论指令的任何特定执行策略，因此由每个GraphQL服务器框架暴露用于执行新指令的API。</p><p>如果使用的是Apollo Server，则使用的是<code>graphql-tools</code>npm包，该包提供了一个方便而强大的工具来实现指令语法：SchemaDirectiveVisitor类。</p><p>要使用<code>SchemaDirectiveVisitor</code>来执行Schema指令，只需创建一个SchemaDirectiveVisitor子类将覆盖以下一个或多个访问器方法：</p><ul><li>visitSchema(schema: GraphQLSchema)</li><li>visitScalar(scalar: GraphQLScalarType)</li><li>visitObject(object: GraphQLObjectType)</li><li>visitFieldDefinition(field: GraphQLField&lt;any, any&gt;)</li><li>visitArgumentDefinition(argument: GraphQLArgument)</li><li>visitInterface(iface: GraphQLInterfaceType)</li><li>visitUnion(union: GraphQLUnionType)</li><li>visitEnum(type: GraphQLEnumType)</li><li>visitEnumValue(value: GraphQLEnumValue)</li><li>visitInputObject(object: GraphQLInputObjectType)</li><li>visitInputFieldDefinition(field: GraphQLInputField)</li></ul><p>通过扩展<code>visitObject</code>的方法，SchemaDirectiveVisitor的子类表达了对某些schema类型（例如GraphQLObjectType的第一个参数类型visitObject）的兴趣。</p><p>这些方法名称对应于schema中使用指令的所有可能位置。例如，<code>INPUT_FIELD_DEFINITION</code>位置由处理<code>visitInputFieldDefinition</code>。</p><p>这是@deprecated我们在上面看到的一种执行指令：</p><pre>const { SchemaDirectiveVisitor } = require("apollo-server");class DeprecatedDirective extends SchemaDirectiveVisitor {  public visitFieldDefinition(field: GraphQLField<any, any>) {    field.isDeprecated = true;    field.deprecationReason = this.args.reason;  }  public visitEnumValue(value: GraphQLEnumValue) {    value.isDeprecated = true;    value.deprecationReason = this.args.reason;  }}</pre><p>为了将此执行应用于包含@deprecated指令的schema，只需DeprecatedDirective通过以下schemaDirectives选项将类传递给Apollo Server的构造函数即可：</p><pre>const { ApolloServer, gql } = require("apollo-server");const typeDefs = gql`  type ExampleType {    newField: String    oldField: String @deprecated(reason: "Use \`newField\`.")  }`;const server = new ApolloServer({  typeDefs,  resolvers,  schemaDirectives: {    deprecated: DeprecatedDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>另外，如果要修改现有的schema对象，则可以直接调用<code>SchemaDirectiveVisitor.visitSchemaDirectives</code>接口：</p><pre>SchemaDirectiveVisitor.visitSchemaDirectives(schema, {  deprecated: DeprecatedDirective});</pre><p>请注意，该<code>@deprecated</code>指令的不同次出现可能会使<code>SchemaDirectiveVisitor</code>的子类会被多次实例化。这就是为什么提供一个类而不是该类的实例的原因。</p><p>如果由于某种原因您有使用schema中该<code>@deprecated</code>指令的其他名名称，但又想使用相同的执行，则可以！DeprecatedDirective只需更改schemaDirectives传递给<br>Apollo Server 构造函数的对象中的键，即可使用不同的名称传递相同的类。换句话说，SchemaDirectiveVisitor实现实际上是匿名的，因此由使用它们来为其分配名称的人来决定。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>为了了解带来的各种可能性SchemaDirectiveVisitor，让我们研究各种实际示例</p><h6 id="大写字符串"><a href="#大写字符串" class="headerlink" title="大写字符串"></a>大写字符串</h6><p>假设您要将字符串值字段转换为大写。尽管此用例很简单，但它是通过包装字段的<code>resolve</code>函数执行指令的一个很好的例子：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const { defaultFieldResolver } = require("graphql");const typeDefs = gql`  directive @upper on FIELD_DEFINITION  type Query {    hello: String @upper  }`;class UpperCaseDirective extends SchemaDirectiveVisitor {  visitFieldDefinition(field) {    const { resolve = defaultFieldResolver } = field;    field.resolve = async function (...args) {      const result = await resolve.apply(this, args);      if (typeof result === "string") {        return result.toUpperCase();      }      return result;    };  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    upper: UpperCaseDirective,    upperCase: UpperCaseDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>注意@upper，@upperCase使用相同的UpperCaseDirective实现来处理这两个过程非常容易。</p><p>######从REST API获取数据<br>假设您已经定义了一个与REST资源相对应的对象类型，并且您想要避免为每个字段实现解析器功能：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const typeDefs = gql`  directive @rest(url: String) on FIELD_DEFINITION  type Query {    people: [Person] @rest(url: "/api/v1/people")  }`;class RestDirective extends SchemaDirectiveVisitor {  public visitFieldDefinition(field) {    const { url } = this.args;    field.resolve = () => fetch(url);  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    rest: RestDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>在REST端点上实现真正的GraphQL包装时，还有许多其他问题需要考虑（例如，如何进行缓存或分页），但是此示例演示了一个基本思路。</p><h6 id="匹配日期字符串"><a href="#匹配日期字符串" class="headerlink" title="匹配日期字符串"></a>匹配日期字符串</h6><p>假设你的解析器返回的是一个 Date对象，但是在客户端需要返回字符串类型</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const typeDefs = gql`  directive @date(format: String) on FIELD_DEFINITION  scalar Date  type Post {    published: Date @date(format: "mmmm d, yyyy")  }`;class DateFormatDirective extends SchemaDirectiveVisitor {  visitFieldDefinition(field) {    const { resolve = defaultFieldResolver } = field;    const { format } = this.args;    field.resolve = async function (...args) {      const date = await resolve.apply(this, args);      return require('dateformat')(date, format);    };    // The formatted Date becomes a String, so the field type must change:    field.type = GraphQLString;  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    date: DateFormatDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>当然，如果Schema的维护者并没有确定具体的Date类型，你可以把这个交给客户端处理会更好一些。为了做到这一点，我们为相应的字段的指令加上参数即可</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const formatDate = require("dateformat");const { defaultFieldResolver, GraphQLString } = require("graphql");const typeDefs = gql`  directive @date(    defaultFormat: String = "mmmm d, yyyy"  ) on FIELD_DEFINITION  scalar Date  type Query {    today: Date @date  }`;class FormattableDateDirective extends SchemaDirectiveVisitor {  public visitFieldDefinition(field) {    const { resolve = defaultFieldResolver } = field;    const { defaultFormat } = this.args;    field.args.push({      name: 'format',      type: GraphQLString    });    field.resolve = async function (      source,      { format, ...otherArgs },      context,      info,    ) {      const date = await resolve.call(this, source, otherArgs, context, info);      // If a format argument was not provided, default to the optional      // defaultFormat argument taken by the @date directive:      return formatDate(date, format || defaultFormat);    };    field.type = GraphQLString;  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    date: FormattableDateDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>现在，当请求<code>Query.today</code>字段，客户端可以在Schema中指定<code>format</code>参数，或者使用默认<code>defaultFormat</code></p><pre>const { request } = require("graphql-request");server.listen().then(({ url }) => {  request(url, `query { today }`).then(result => {    // Logs with the default "mmmm d, yyyy" format:    console.log(result.data.today);  });  request(url, `query {    today(format: "d mmm yyyy")  }`).then(result => {    // Logs with the requested "d mmm yyyy" format:    console.log(result.data.today);  });})</pre><h6 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h6><p>假设你有一个``translate`函数，该函数需要一个字符串，一个标识该字符串在应用程序中角色路径，和需要转换的目标语言环境。</p><p>您可以按照以下方式确定<code>translate</code>用于本地化类型的<code>greeting</code>字段<code>Query</code></p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const typeDefs = gql`  directive @intl on FIELD_DEFINITION  type Query {    greeting: String @intl  }`;class IntlDirective extends SchemaDirectiveVisitor {  visitFieldDefinition(field, details) {    const { resolve = defaultFieldResolver } = field;    field.resolve = async function (...args) {      const context = args[2];      const defaultText = await resolve.apply(this, args);      // In this example, path would be ["Query", "greeting"]:      const path = [details.objectType.name, field.name];      return translate(defaultText, path, context.locale);    };  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    intl: IntlDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>GraphQL很适合做国际化，因为GraphQL server 没有限制访问的翻译数据，客户端只要按需请求即可</p><h6 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h6><p>假设我们有一个 @auth 指令，他接收<code>requires</code>参数是<code>Role</code>枚举类，默认类型是<code>ADMIN</code>。这个@auth指令作用于<code>OBJECT</code>（像<code>User</code>类型）<br>对所有的User类型 或者 特定的类型 设置访问权限。</p><pre>directive @auth(  requires: Role = ADMIN,) on OBJECT | FIELD_DEFINITIONenum Role {  ADMIN  REVIEWER  USER  UNKNOWN}type User @auth(requires: USER) {  name: String  banned: Boolean @auth(requires: ADMIN)  canPost: Boolean @auth(requires: REVIEWER)}</pre><p>使这个示例棘手的是，指令需要<code>OBJECT</code>的版本包装着对象的所有字段，即使其中某些字段可能<code>@auth</code>在该<code>FIELD_DEFINITION</code>级别由指令单独包装，<br>并且如果我们可以自己处理的话，最好不要重新包装解析器：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");class AuthDirective extends SchemaDirectiveVisitor {  visitObject(type) {    this.ensureFieldsWrapped(type);    type._requiredAuthRole = this.args.requires;  }  // Visitor methods for nested types like fields and arguments  // also receive a details object that provides information about  // the parent and grandparent types.  visitFieldDefinition(field, details) {    this.ensureFieldsWrapped(details.objectType);    field._requiredAuthRole = this.args.requires;  }  ensureFieldsWrapped(objectType) {    // Mark the GraphQLObjectType object to avoid re-wrapping:    if (objectType._authFieldsWrapped) return;    objectType._authFieldsWrapped = true;    const fields = objectType.getFields();    Object.keys(fields).forEach(fieldName => {      const field = fields[fieldName];      const { resolve = defaultFieldResolver } = field;      field.resolve = async function (...args) {        // Get the required Role from the field first, falling back        // to the objectType if no Role is required by the field:        const requiredRole =          field._requiredAuthRole ||          objectType._requiredAuthRole;        if (! requiredRole) {          return resolve.apply(this, args);        }        const context = args[2];        const user = await getUser(context.headers.authToken);        if (! user.hasRole(requiredRole)) {          throw new Error("not authorized");        }        return resolve.apply(this, args);      };    });  }}const server = new ApolloServer({  typeDefs,  schemaDirectives: {    auth: AuthDirective,    authorized: AuthDirective,    authenticated: AuthDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><p>这种方法的一个缺点是，它不能保证如果在<code>AuthDirective</code>调用之后将字段添加到<code>Schema</code>中时，字段会被包装，并且整个<br><code>getUser(context.headers.authToken)</code>虚构的API仍需要充实。换句话说，虽然我们忽略了执行该指令可用于生产环境的所需要的一些细节，但是我们希望<br>此处显示的基本结构能够激发您找到解决现存问题解决方案。</p><h6 id="值限制"><a href="#值限制" class="headerlink" title="值限制"></a>值限制</h6><p>假设您要为字符串值字段设置最大长度：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require('apollo-server');const { GraphQLScalarType, GraphQLNonNull } = require('graphql');const typeDefs = gql`  directive @length(max: Int) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION  type Query {    books: [Book]  }  type Book {    title: String @length(max: 50)  }  type Mutation {    createBook(book: BookInput): Book  }  input BookInput {    title: String! @length(max: 50)  }`;class LengthDirective extends SchemaDirectiveVisitor {  visitInputFieldDefinition(field) {    this.wrapType(field);  }  visitFieldDefinition(field) {    this.wrapType(field);  }  // Replace field.type with a custom GraphQLScalarType that enforces the  // length restriction.  wrapType(field) {    if (      field.type instanceof GraphQLNonNull &&      field.type.ofType instanceof GraphQLScalarType    ) {      field.type = new GraphQLNonNull(        new LimitedLengthType(field.type.ofType, this.args.max),      );    } else if (field.type instanceof GraphQLScalarType) {      field.type = new LimitedLengthType(field.type, this.args.max);    } else {      throw new Error(`Not a scalar type: ${field.type}`);    }  }}class LimitedLengthType extends GraphQLScalarType {  constructor(type, maxLength) {    super({      name: `LengthAtMost${maxLength}`,      // For more information about GraphQLScalar type (de)serialization,      // see the graphql-js implementation:      // https://github.com/graphql/graphql-js/blob/31ae8a8e8312/src/type/definition.js#L425-L446      serialize(value) {        value = type.serialize(value);        assert.isAtMost(value.length, maxLength);        return value;      },      parseValue(value) {        return type.parseValue(value);      },      parseLiteral(ast) {        return type.parseLiteral(ast);      },    });  }}const server = new ApolloServer({  typeDefs,  resolvers,  schemaDirectives: {    length: LengthDirective,  },});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><h6 id="生成唯一ID"><a href="#生成唯一ID" class="headerlink" title="生成唯一ID"></a>生成唯一ID</h6><p>假设您的数据库对每种资源类型都使用递增ID，而且ID在所有资源类型中都不都是唯一的。您可以通过以下方法合成一个名为的字段uid，该字段将对象类型与各<br>种字段值结合在一起，以产生一个在整个Schema中唯一的ID：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const { GraphQLID } = require("graphql");const { createHash } = require("crypto");const typeDefs = gql`  directive @uniqueID(    # The name of the new ID field, "uid" by default:    name: String = "uid"    # Which fields to include in the new ID:    from: [String] = ["id"]  ) on OBJECT  # Since this type just uses the default values of name and from,  # we don't have to pass any arguments to the directive:  type Location @uniqueID {    id: Int    address: String  }  # This type uses both the person's name and the personID field,  # in addition to the "Person" type name, to construct the ID:  type Person @uniqueID(from: ["name", "personID"]) {    personID: Int    name: String  }`;class UniqueIdDirective extends SchemaDirectiveVisitor {  visitObject(type) {    const { name, from } = this.args;    const fields = type.getFields();    if (name in fields) {      throw new Error(`Conflicting field name ${name}`);    }    fields[name] = {      name,      type: GraphQLID,      description: 'Unique ID',      args: [],      resolve(object) {        const hash = createHash("sha1");        hash.update(type.name);        from.forEach(fieldName => {          hash.update(String(object[fieldName]));        });        return hash.digest("hex");      }    };  }}const server = new ApolloServer({  typeDefs,  resolvers,  schemaDirectives: {    uniqueID: UniqueIdDirective  }});server.listen().then(({ url }) => {  console.log(`🚀 Server ready at ${url}`);});</pre><h5 id="声明Schema指令"><a href="#声明Schema指令" class="headerlink" title="声明Schema指令"></a>声明Schema指令</h5><p>尽管上述例足以执行你在Schema中使用的任何<code>@directive</code>，但是SDL 预发还支持声明名称，参数类型，默认参数以及允许使用指令的位置</p><pre>directive @auth(  requires: Role = ADMIN,) on OBJECT | FIELD_DEFINITIONenum Role {  ADMIN  REVIEWER  USER  UNKNOWN}type User @auth(requires: USER) {  name: String  banned: Boolean @auth(requires: ADMIN)  canPost: Boolean @auth(requires: REVIEWER)}</pre><p>该假设@auth指令参数为requires，参数类型为Role，如果<code>@auth</code>不传递显式requires参数默认值是ADMIN，。该@auth指令可以出现在像<code>User</code>这样<br>的<code>OBJECT</code>上，为所有User字段设置默认访问控制，也可以在单个字段上限制。</p><p>从理论上讲满足声明的要求是<code>SchemaDirectiveVisitor</code>执行本身可以完成的事情，但是SDL语法更易于读写，即使没有使用SchemaDirectiveVisitor抽象也可以提供值。</p><p>但是，如果要实现可重用SchemaDirectiveVisitor的公共用途，则可能不是编写SDL语法的人，因此您可能无法控制schema开发者决定声明哪些指令以及如何声明。<br>这就是为什么一个执行良好，可重用<code>SchemaDirectiveVisitor</code>的方法应该考虑重写<code>getDirectiveDeclaration</code>方法：</p><pre>const { ApolloServer, gql, SchemaDirectiveVisitor } = require("apollo-server");const { DirectiveLocation, GraphQLDirective, GraphQLEnumType } = require("graphql");class AuthDirective extends SchemaDirectiveVisitor {  public visitObject(object: GraphQLObjectType) {...}  public visitFieldDefinition(field: GraphQLField<any, any>) {...}  public static getDirectiveDeclaration(    directiveName: string,    schema: GraphQLSchema,  ): GraphQLDirective {    const previousDirective = schema.getDirective(directiveName);    if (previousDirective) {      // If a previous directive declaration exists in the schema, it may be      // better to modify it than to return a new GraphQLDirective object.      previousDirective.args.forEach(arg => {        if (arg.name === 'requires') {          // Lower the default minimum Role from ADMIN to REVIEWER.          arg.defaultValue = 'REVIEWER';        }      });      return previousDirective;    }    // If a previous directive with this name was not found in the schema,    // there are several options:    //    // 1. Construct a new GraphQLDirective (see below).    // 2. Throw an exception to force the client to declare the directive.    // 3. Return null, and forget about declaring this directive.    //    // All three are valid options, since the visitor will still work without    // any declared directives. In fact, unless you're publishing a directive    // implementation for public consumption, you can probably just ignore    // getDirectiveDeclaration altogether.    return new GraphQLDirective({      name: directiveName,      locations: [        DirectiveLocation.OBJECT,        DirectiveLocation.FIELD_DEFINITION,      ],      args: {        requires: {          // Having the schema available here is important for obtaining          // references to existing type objects, such as the Role enum.          type: (schema.getType('Role') as GraphQLEnumType),          // Set the default minimum Role to REVIEWER.          defaultValue: 'REVIEWER',        }      }]    });  }}</pre><p>由于<code>getDirectiveDeclaration</code>方法不仅接收指令的名称，而且还接收GraphQLSchema对象，因此它可以修改和/或重用在Schema中找到的先前的声明，作为替代方法返回<br>全新GraphQLDirective对象。无论哪种方式，如果访问者返回一个非空GraphQLDirective的getDirectiveDeclaration，该声明将被用来检查参<br>数和允许的位置。</p><h5 id="查询指令"><a href="#查询指令" class="headerlink" title="查询指令"></a>查询指令</h5><p>顾名思义，该SchemaDirectiveVisitor抽象经过专门设计，可以根据SDL文本中显示的指令来转换GraphQL schema。</p><p>虽然指令语法也可以出现在从客户端发送的GraphQL查询中，但是执行查询指令将需要查询文档的运行时转换。我们故意将这种实现方式限制为在服务器构造时进行转换。</p><p>我们相信，将这种逻辑限制在您的schema中比负担您的客户更加可持续，尽管您可能会想到实现查询指令的类似抽象。如果这种可能性成为您的需要，请告诉我们，<br>我们可能会考虑在这些工具的未来版本中支持查询指令。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
